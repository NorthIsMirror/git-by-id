#compdef git-bid=git
#!/usr/bin/env zsh
# code: language=zsh
setopt re_match_pcre
zmodload zsh/pcre
# ---------------------------------------------------------------------------- #
#                                   Git By Id                                  #
# ---------------------------------------------------------------------------- #


# ------------------------------- git-bid-setup ------------------------------ #
(( $+GIT_BY_ID[__SETUP__] )) || {
    # set up completions
    (( $+functions[compdef] )) && compdef git-bid=git git-by-id=git

    # Config map, set as global assoiative array
    typeset -Ag GIT_BY_ID

    (( !$+GIT_BY_ID[GIT_CMD] )) && {
        # the underlying git command name, "git" by default
        # the git command will be found via $commands[${GIT_BY_ID[GIT]}]
        GIT_BY_ID[GIT]="${GIT_BY_ID[GIT]:-git}"

        # require git binary actually exists
        if (( !$+commands[${GIT_BY_ID[GIT]}] )) {
            print -Pu2 "%F{red}can not find git command '${GIT_BY_ID[GIT]}'%f"
            return 1
        }
    }

    # full path to the git command, this path is what is actually used byt git-by-id
    GIT_BY_ID[GIT_CMD]="${GIT_BY_ID[GIT_CMD]:-$commands[$GIT_BY_ID[GIT]]}"

    # log lots of output, options are {0, 1, 2}
    # per command verbosity levels via GIT_BY_ID[VERBOSITY__git-<COMMAND>]
    GIT_BY_ID[VERBOSITY]="${GIT_BY_ID[VERBOSITY]:-2}"

    # enable color
    GIT_BY_ID[NO_COLOR]="${GIT_BY_ID[NO_COLOR]:-0}"

    # debug log of every git-by-id command
    GIT_BY_ID[LOG_COMMANDS]="${GIT_BY_ID[LOG_COMMANDS]:-0}"

    # location to dump a history of unwrapped commands
    GIT_BY_ID[LOGFILE]="${GIT_BY_ID[LOGFILE]:-/usr/local/var/log/git-bid.log}"

    # should id variables (`g23`, etc.) be set when creating the ids
    GIT_BY_ID[SET_ID_VARS]="${GIT_BY_ID[SET_ID_VARS]:-1}"
    
    # the git id variable prefix, defaults to "g"
    GIT_BY_ID[PREFIX_VAR]="${GIT_BY_ID[PREFIX_VAR]:-g}"

    local _theme='ob=black:cb=black'
    GIT_BY_ID[THEME]="${GIT_BY_ID[THEME]:-'ob=black:cb=black'}"
    typeset -Ag GIT_BY_ID_THEME

    for segment in ${(s@:@)GIT_BY_ID[THEME]} ; {
        if [[ segment =~ (ob|cb)=(\w+) ]] {
            key=$match[1]
            color=$match[2]
            case $key ; {
                ob) char='[' ;;
                cb) char=']' ;;
                *) char='' ;;
            }
            GIT_BY_ID_THEME[$key]="${fg[$color]}$char$reset_color"
        } else {
            print -u2 "'$segment' is an invalid theme option"
        }
    }
    # check to see if git is using a custom pager
    # GIT_BY_ID[COLOR_PAGER]=0
    # [[ "$($commands[${GIT_BY_ID[GIT]}] config --get core.pager 2>/dev/null)" =~ 'git-bid-color' ]] && GIT_BY_ID[COLOR_PAGER]=1

    # set up git alias unpacking
    # this makes it so if you have an alias of `alias.st=status` then `git-by-id st` will know you mean `status`
    local key _aliases=$($GIT_BY_ID[GIT_CMD] config --get-regexp alias)
    function find-alias() { (( $+GIT_BY_ID[ALIAS_$1] )) && find-alias "$GIT_BY_ID[ALIAS_$1]" || echo $1 }
    for a in ${(f)_aliases} ; {
        # looks for simple aliases and alias functions with a well formed `: git <cmd>` as the first statement
        [[ $a =~ '^alias.(\w+)\s+(\w+)' || $a =~ '^alias.(\w+)\s+!.*:\s*git\s+(\w+)' ]] \
            && GIT_BY_ID[ALIAS_${match[1]}]="${match[2]}"
    }
    for key in ${(k)GIT_BY_ID[(I)ALIAS_*]} ; {
        GIT_BY_ID[$key]="$(find-alias ${key#ALIAS_*})"  # use find-alias to recursively unpack aliases
    }

    # mark time that setup completes (1 if EPOCHREALTIME is disabled)
    GIT_BY_ID[__SETUP__]=${EPOCHREALTIME:-1}

    # freeze settings
    readonly -Ag GIT_BY_ID

    # proactively source the file before continuing
    # this loads all the functions and enables faster loading of the commands
    # in subsequent runs this will speed up execution
    source $functions_source[git-by-id]
}

# -------------------------------- entrypoints ------------------------------- #
(( $+functions[git-bid-entrypoint] )) && {
    # this short-cuts loading the rest of the file when already sourced
    git-bid-entrypoint "$@"
    return $status
} || function git-bid-entrypoint() {
    if [[ "$1" == 'refunc' ]] {
        xlg-cmd git-bid-teardown
        return $status
    } else {
        # run the function like normal!
        export LINES
        # disable color for now
        if (( 0 && $+functions[git-bid-color] )) {
            # run output through a fancy colorizer (but its kinda broken)
            if [[ "$1" == diff ]] {
                git-bid "$@" 2> >(git-bid-color stderr)
            } elif (( $+functions[git-bid-color] )) {
                git-bid "$@" > >(git-bid-color stdout) 2> >(git-bid-color stderr)
            }
        } else {
            # run git-bid
            git-bid "$@"
        }
        return $status
    }
}

(( $+functions[git-bid-teardown] )) || function git-bid-teardown() {
    local \
        function_path="${functions_source[git-bid]}" \
        bid_funcs=(
            ${(k)functions[(I)git-by-id*]}
            ${(k)functions[(I)git-bid*]}
        )

    print -Pu2 '%F{yellow}unloading functions%F{white}:' "\n"'  %F{white}- %F{yellow}'${^bid_funcs}'%f'
    xlg-cmd unfunction $bid_funcs
    xlg-cmd autoload git-by-id
    [[ "$@" =~ '--no-setup' ]] || xlg-cmd source $function_path 'git-bid-setup'
}

# ---------------------------------------------------------------------------- #
#                                   Git By Id                                  #
# ---------------------------------------------------------------------------- #
(( $+functions[git-bid] )) || function git-bid() {
    [[ "$__trace__" ]] && set -x || set +x
    local \
        extra_args=() \
        cmd="$GIT_BY_ID[GIT_CMD]" \
        unwrapped_cmd \
        branch

    (( $GIT_BY_ID[LOG_COMMANDS] )) && {
        # logs all git-bid commands to a log
        print "[$(date)] git-bid $@" >> $GIT_BY_ID[LOGFILE]
    }

    # unwrap the cmd to see if it is an alias, then use that for 
    unwrapped_cmd="${GIT_BY_ID[ALIAS_$1]:-$1}"
    [[ "$1" != "$unwrapped_cmd" ]] && {
        xlg "%F{white}[%F{green}git %F{magenta}$1 %F{white}-> %F{green}git %F{magenta}$unwrapped_cmd%F{white}]%f"
    }

    case "$unwrapped_cmd" {
        (*by-id-setup)
            # run setup
            git-bid-shell-usage
            ;;
        (t | git)
            # handle funny cases of `gi t<cmd>` or `git git <cmd>`
            git-bid-tgit "$@"
            ;;
        (stash)
            git-bid-stash "$@"
            ;;
        (status)
            git-bid-number "${@[2,-1]}"
            ;;
        (commit | add | merge )  # add verbose args
            extra_args+=--verbose
            ;&
        (commit | blame | add | log | rebase | merge | difftool)
            git-bid-number-expand --byid-execute $cmd $1 $extra_args "${@:2}"
            ;;
        (rm)
            extra_args+=--byid-remove
            ;&
        (diff | rm | reset)
            git-bid-number-expand --byid-execute --byid-relative $cmd $extra_args "$@"
            ;;
        (checkout)  # branch orenited things
            git-bid-checkout "$@"
            ;;
        (branch)
            git-bid-number-branch "${@:2}"
            ;;
        (next)
            # git next BRANCH_BASE EXTRA_PHRASE
            [[ "$2" ]] || {print -u2 "need a branch name" ; return 1}
            local phrase=("$2-next" "${3// /-}")
            xlg-cmd git checkout -b "${(@j:-:)phrase:#}"
            ;;
        (fork)
            gh repo fork "${@:2}"
            ;;

        (push)
            git-bid-push "$@"
            ;;
        (refunc|bid-refunc)
            git-bid-teardown
            ;;
        (unfunc|bid-unfunc)
            git-bid-teardown --no-setup
            ;;
        (*)
            (( $+commands[git-$1] || $+functions[git-$1] )) && {
                # run custom git-* commands directly
                cmd="git-$1" ; shift
            }
            xlg-cmd $cmd "$@"
            ;;
    }
    return $status
}

# ----------------------------------- utils ---------------------------------- #
(( $+functions[xlg-error] )) || function xlg-error() {
    xlg %"F{red}%B$@%b%f"
}

(( $+functions[xlg-debug] )) || function xlg-debug() {
    (( GIT_BY_ID[VERBOSITY] >= 2 )) && xlg "%F{black}$@%f"
}

(( $+functions[xlg-cmd] )) || function xlg-cmd() {
    # helper to log a command to stderr

    # allow for per-git-command verbosity levels via GIT_BY_ID[VERBOSITY__git-<COMMAND>]
    local verbosity="${GIT_BY_ID[VERBOSITY]}"
    if [[ "$1" == "$GIT_BY_ID[GIT_CMD]" ]] {
        verbosity="${GIT_BY_ID[VERBOSITY__git-$2]:-$verbosity}"
    }

    (( verbosity >= 1 )) && xlg "%B$1%b ${@:2}"

    "$@"
}

(( $+functions[xlg] )) || function xlg() {
    print -Pu2 "+> $@"
}

# ----------------------------- helper funcitons ----------------------------- #
(( $+functions[git-bid-color] )) || function git-bid-color() {
    [[ "$1" == stderr ]] && extra="a = STDERRIZE(a);"
    gawk -i stdlib.awk -v outfile="/dev/$1" '
    function foo(hello) { return "there"; }
    function recolor(expression, colorize) { a = gensub(expression, colorize, "g", a); }
    BEGIN {
        M1="\\1"
        M2="\\2"

        # git
        recolors["(CONFLICT)"] = RED(M1)
        recolors["(fatal:)(.*)"] = BRIGHT_RED(M1)RED(M2)
        recolors["(Continuing in [[:digit:].]+ seconds)"] = YELLOW(M1)
        recolors["(Everything up-to-date)"] = GREEN(M1)

        # pre-commit
        recolors["(Passed)$"] = GREEN(M1)
        recolors["(Skipped)$"] = YELLOW(M1)
        recolors["(.*Failed)$"] = RED(M1)

        # branches
        recolors["(master)"] = MAGENTA(M1);
        recolors["(main)"] = MAGENTA(M1);
    }
    {
        a = $0
        for (expr in recolors) {
            a = gensub(expr, recolors[expr], "g", a)
        }
        '$extra'
        print(a) > outfile;
    }' -
}

(( $+functions[git-bid-config] )) || function git-bid-config() {
    __config_ret=$(${GIT_BY_ID[GIT]} config $@ 2>/dev/null)
    print "$__config_ret"
}

(( $+functions[git-bid-shell-usage] )) || function git-bid-shell-usage() {
    # Setup for shell
    cat <<- EOF
	# add the following to an init script
	alias git="git-bid"
	alias gi="git"
	EOF
}


(( $+functions[git-bid-clean-vars] )) || function git-bid-clean-vars() {
    # reset the vairables used in each run
    typeset -g \
        GIT_IDS_COUNT=0

    typeset -Ag \
        GIT_IDS=() \
        GIT_IDS_STAGED=() \
        GIT_IDS_UNMERGED=() \
        GIT_IDS_UNSTAGED=() \
        GIT_IDS_UNTRACKED=() \
        GIT_IDS_BRANCHES=()

    unset -m "${GIT_BY_ID[PREFIX_VAR]}[0-9]##"
}

# ------------------------------- git-bid-tgit ------------------------------- #
(( $+functions[git-bid-tgit] )) || function git-bid-tgit() {
    # handle `gi t` and `git git`
    local _g=$fg[green] _m=$fg[magenta] _w=$fg[white] _r=$fg[red] _rc=$reset_color \
        msg args

    [[ "${@:3}" ]] && local extra=" $_m${@:3}$_rc"
    case $1 {
        (t)
            msg="${_w}[${_g}gi ${_r}t${_m}${2#t} ${_w}-> ${_g}git ${_m}${2#t}${_w}]$_rc$extra$_rc"
            args=("${2#t}" "${@:3}")
            ;;
        (git)
            msg="${_w}[${_g}git ${_r}git ${_m}${2} ${_w}-> ${_g}git ${_m}${2}${_w}]$_rc$extra$_rc"
            args=("${@:2}")
            ;;
    }

    xlg "$msg"
    git-bid $args
}

# ------------------------------ git-bid-stash ------------------------------ #
(( $+functions[git-bid-stash] )) || function git-bid-stash() {
    if [[ $1 == stash && $2 == pop ]] {
        # handle stah pop -> git stash pop --quiet &&
        $cmd "$@" --quiet
        shift
    } elif [[ $1 == stash ]] {
        $cmd "$@"
        return $status
    }

    git-bid-number "$@[2,-1]"
}

# ----------------------------- git-bid-checkout ----------------------------- #
(( $+functions[git-bid-checkout] )) || function git-bid-checkout() {
    local bi
    if [[ ${bi:=${@[(i)-b]}} -le ${#@} ]] {
        # check for -b group/project-next
        (( bi++ ))
        local co_branch=${@[$bi]}
        if [[ "$co_branch" =~ "next" ]] {
            local \
                group="$(whoami)" \
                project='' \
                flavor=''

            if [[ "$co_branch" =~ "^next-?(.*)$" ]] {
                flavor="$match[1]"
            } elif [[ "$co_branch" =~ "^(.*)/next-?(.*)$" ]] {
                group="$match[1]"
                flavor="$match[2]"
            } elif [[ "$co_branch" =~ "^(.*)/(.*)-next-?(.*)$" ]] {
                group="$match[1]"
                project="$match[2]"
                flavor="$match[3]"
            }

            local config_key="git-bid.${group}-${project}"
            local counter=${$(git-bid-config "$config_key"):-0}

            git-bid-config --replace-all --int "$config_key" $(( ++counter ))

            [[ "$project" ]] && project="$project-"
            [[ "$flavor" ]] && flavor="-$flavor"

            co_branch="$group/$project$counter$flavor"

            xlg "next branch: %F{magenta}$co_branch%f"

            args=($@)
            args[$bi]="$co_branch"
            set - $args

        }
    }

    # run the git checkout command
    git-bid-number-expand --byid-execute --byid-branch $cmd "$@"
    local co_status=$status
    case "$co_status" {
        ( 0 )
            return 0
            ;;
        ( 128 )
            __git-bid-handle-accidental-branch "$@"
            co_status=$status
            ;;
    }
    if (( co_status )) && [[ "$bi" && "$config_key" && "$counter" ]] {
        # decrement the counter if we failed to make the branch
        git-bid-config --replace-all --int "$config_key" $(( --counter ))
    }
    return $co_status
}

(( $+functions[__git-bid-handle-accidental-branch] )) || function __git-bid-handle-accidental-branch() {
    # if status is 128 check to see if this was an "accidental branch creation"
    result=$(git-bid-number-expand --byid-execute --byid-branch $cmd "$@" 2>&1)
    if [[ "$result" =~ "fatal: A branch named '(.*)' already exists." ]] {
        local branch="${match[1]}"
        local sleep_time=$(printf '%.1f' $(($(git-bid-config help.autocorrect) / 10.0)) )

        msg=(
            "%F{$_orange}WARNING%f: You tried to make a branch that already exists."
            "Continuing in $sleep_time seconds, assuming that you meant 'checkout'."
        )
        print -Pu2 ${(j:\n:)msg}

        sleep $sleep_time

        xlg-cmd $cmd $1 "$branch"
        return $status
    }
    return 0
}

# ------------------------------- git-bid-push ------------------------------- #
(( $+functions[git-bid-push] )) || function git-bid-push() {
    if [[
        -t 1  # check if fd1 is open for read
        && "$($cmd branch --show-current)" =~ '(master|main)'
    ]] {
        local should_push nl=$'\n'
        until [[ "${should_push:l}" =~ '(y|yes|n|no)$' ]] {
            read should_push\?"Push to ${match[1]}? [y/N]?${nl}> "
            [[ ${${should_push:-no}:l} =~ '^(n|no|exit)$' ]] && return 1
        }
    }
    $cmd $@
}

# ---------------------------------------------------------------------------- #
#                               number functions                               #
# ---------------------------------------------------------------------------- #

# ------------------------------- number expand ------------------------------ #
(( $+functions[git-bid-number-expand] )) || function git-bid-number-expand() {
    # Allows expansion of numbered shortcuts, ranges of shortcuts, or standard paths.
    # Return a string which can be `eval`ed like: eval args="$(scmb_expand_args "$@")"
    # Numbered shortcut variables are produced by various commands, such as:
    # * git_status_shortcuts()    - git status implementation
    # * git_show_affected_files() - shows files affected by a given SHA1, etc.

    # Check for --relative param
    local \
        branch \
        execute \
        relative \
        remove \
        args=() \
        cmd \
        i

    zparseopts -E -D -- \
        -byid-branch=branch \
        -byid-execute=execute \
        -byid-relative=relative \
        -byid-remove=remove \


    function prel() {
        (( $+GIT_IDS[$1] )) || {
            xlg-error "id [$1] hasn't been set yet"
            return 1
        }
        
        local p="${GIT_IDS[$1]}"
        [[ $relative ]] && p=${p#$PWD/}

        if [[ "$remove" || "$branch" ]] {
            # just keep going, the branch/file doesn't need to exist
        } elif [[ "$p" && ! -e "$p" ]] {
            xlg-error "'$p' doesn't seem to exist"
            return 1
        }

        xlg-debug "[$1] -> $p"
        args+="$p"
    }

    setopt re_match_pcre
    for arg in "$@"; do
        xlg-debug "arg: $arg"
        if [[ "$arg" =~ ^[0-9]{1,4}$ ]] {
            # Substitute $e{*} variables for any integers
            if [[ -e "$arg" ]] {
                # Don't expand files or directories with numeric names
                args+="$arg"
            } else {
                prel $arg || return $status
            }
        } elif [[ "$arg" =~ ^([0-9]{1,4})(?:[-,]|[.]{2})([0-9]{1,4})$ ]] {
            # Expand ranges into $e{*} variables
            for i in {$match[1]..$match[2]}; {
                prel $i || return $status
            }
        } else {
            # Otherwise, treat $arg as a normal string.
            args+="$arg"
        }
    done

    cmd=( ${args[@]} )
    xlg-debug "expanded $cmd"
    if [[ "$execute" ]] {
        xlg-cmd $cmd
        return $status
    } else {
        print "$cmd"
        return 0
    }

}

# ------------------------------- number branch ------------------------------ #
(( $+functions[git-bid-number-branch] )) || function git-bid-number-branch() {
    git-bid-clean-vars

    # Fall back to normal git branch, if any unknown args given
    if (( $(${GIT_BY_ID[GIT]} branch | wc -l) > 300 )) || [[ -n "$@" && "$@" != "-a" ]]; then
        git-bid-number-expand --byid-execute ${GIT_BY_ID[GIT]} branch "$@"
        return $status
    fi

    #TODO add info about commit message: git log master..$branch --oneline | tail -1
    local branches branch i=0
    branches=( ${(f)"$(${GIT_BY_ID[GIT]} branch --color=always ${@})"} )
    for line in ${branches} ; {
        if [[ "$line" =~ "^([ *]{2})(.*)" ]] {
            branch="${match[2]}"
            print -P "$match[1]%F{black}[%f$((++i))%F{black}]%f $match[2]"
            # print -P $(git log --oneline master..$branch | tail -1)
        } else {
            xlg-error "no match '$line'"
        }
    }


    # Set numbered file shortcut in variable
    local IFS=$'\n' branch
    for branch in $(${GIT_BY_ID[GIT]} branch "$@" | sed "s/^[* ]\{2\}//"); do
        (( GIT_IDS_COUNT++ ))
        (( GIT_BY_ID[SET_ID_VARS] )) && \
        (( GIT_BY_ID[SET_ID_VARS] )) && \
                export $GIT_BY_ID[PREFIX_VAR]$GIT_IDS_COUNT="$branch"
        GIT_IDS+=([$GIT_IDS_COUNT]="$branch")
        GIT_IDS_BRANCHES+=([$GIT_IDS_COUNT]="$branch")
    done
}

# ---------------------------------- number ---------------------------------- #
(( $+functions[git-bid-number] )) || function git-bid-number() {
    # Git status --porcelain output
    # X          Y     Meaning
    # -------------------------------------------------
    #          [AMD]   not updated
    # M        [ MD]   updated in index
    # A        [ MD]   added to index
    # D                deleted from index
    # R        [ MD]   renamed in index
    # C        [ MD]   copied in index
    # [MARC]           index and work tree matches
    # [ MARC]     M    work tree changed since index
    # [ MARC]     D    deleted in work tree
    # [ D]        R    renamed in work tree
    # [ D]        C    copied in work tree
    # -------------------------------------------------
    # D           D    unmerged, both deleted
    # A           U    unmerged, added by us
    # U           D    unmerged, deleted by them
    # U           A    unmerged, added by them
    # D           U    unmerged, deleted by us
    # A           A    unmerged, both added
    # U           U    unmerged, both modified
    # -------------------------------------------------
    # ?           ?    untracked
    # !           !    ignored
    # -------------------------------------------------

    local \
        git_args=(-c color.status=always) \
        output=() \
        grouping \
        line section \
        quiet

    git-bid-clean-vars

    zparseopts -E -D -- q=quiet -quiet=quiet

    git_status=( "${(f@)$(/usr/bin/env git $git_args status "$@")}" )
    GIT_IDS_COUNT=0

    local ob="${fg[black]}[$reset_color" cb="${fg[black]}]$reset_color"

    local ansi='\033\[[[:digit:]|;]*m'
    for line in "${(@)git_status}" ; {
        local match=() found_file=
        if [[ -z $line ]] {
        } elif [[ "$line" =~ "^($ansi)\s+\(.*\)" ]] {
        } elif [[ "$line" =~ 'Changes to be committed:' ]] {
            section=GIT_IDS_STAGED
        } elif [[ "$line" =~ 'Changes not staged for commit:' ]] {
            section=GIT_IDS_UNMERGED
        } elif [[ "$line" =~ 'Unmerged paths:' ]] {
            section=GIT_IDS_UNTRACKED
        } elif [[ "$line" =~ 'Untracked files:' ]] {
            section=GIT_IDS_UNTRACKED
        } elif [[ "$line" =~ "(\s+)($ansi)*(.*[deleted|both modified|modified|new file])(:)(\s+)(.*)$" ]] {
            local match_names=( lpad line_color kind colon rpad found_file ) i=0
            for (( i=1 ; i <= ${#match_names} ; i++ ))  local "${match_names[i]}"="$match[$i]"
            [[ "$__trace__" && "$line_color" ]] && print -P "$kind ${line_color}found a color => %f${(q)line_color}"
            case "$kind" {
                (deleted)         kind="%F{red}-$line_color$kind" ;;
                (new*)            kind="%F{green}%B+%b$line_color$kind" ;;
                (both modified)   kind="%F{magenta}%B~%b%F{red}$kind" ;;
                (modified)        kind="%F{yellow}+$line_color$kind" ;;
                (*)               kind="?$line_color$kind" ; xlg "plz handle '$kind'" ;;
            }
            : $(( ++GIT_IDS_COUNT ))
            local id_pad="__id_pad_${#GIT_IDS_COUNT}"  # add padding to the number based on how many files we have seen
            line="$lpad$ob$GIT_IDS_COUNT$cb$id_pad $kind$colon$line_color$rpad$found_file"
        } elif [[ "$line" =~ "(\t)(.*)" ]] {
            local lpad="$match[1]" found_file="$match[2]"
            line="$lpad$ob$(( ++GIT_IDS_COUNT ))$cb $found_file"
        }

        output+="$line"

        if [[ "${found_file}" ]] {
            found_file="${found_file//$'\033'\[([0-9;])#m/}"
            GIT_IDS+=([$GIT_IDS_COUNT]="$found_file")
            typeset -x "${section}[$GIT_IDS_COUNT]"="$found_file"
            (( GIT_BY_ID[SET_ID_VARS] )) && \
                export ${GIT_BY_ID[PREFIX_VAR]}$GIT_IDS_COUNT="$found_file"
        }
    }

    if [[ ! "$quiet" && "$output" ]] {
        # escape ` in output, print -P was interpreting them
        output="${(j:\n:)output:gs/\`/\\\\\`/}\n"
        (( GIT_IDS_COUNT >= 10 )) && output=${output//__id_pad_1/__id_pad_2 }
        (( GIT_IDS_COUNT >= 100 )) && output=${output//__id_pad_2/__id_pad_3 }
        (( GIT_IDS_COUNT >= 1000 )) && output=${output//__id_pad_3/__id_pad_4 }
        (( GIT_IDS_COUNT >= 10000 )) && output=${output//__id_pad_4/ }
        output=${output//__id_pad_[0-9]/}

        print -P "$output"

    }
    return $(( !GIT_IDS_COUNT ))
}
