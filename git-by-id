#compdef git-bid=git
#!/usr/bin/env zsh
# code: language=zsh
setopt re_match_pcre
zmodload zsh/pcre
# ---------------------------------------------------------------------------- #
#                                   Git By Id                                  #
# ---------------------------------------------------------------------------- #
(( $+functions[-git-by-id] )) || function -git-by-id() {
    local start_time=$SECONDS
    (( ${__line_trace__:-0} )) && set -x || set +x  # turn on full tracing of the git command

    if (( ! $+GIT_BY_ID__SETUP_COMPLETE )) {
        autoload -Uz -- git-bid-setup
        git-bid-setup && {
            print -u2 "setup success" 
        } || {
            print -u2 "setup failed"
            return 1
        }
    } else {
        _bid-lg-trace "git-by-id: entrypoint already sourced, using shortcut"
    }

    _bid-lg-trace "setup at: ${GIT_BY_ID__SETUP_COMPLETE}"

    if (( ${@[(Ie)refunc]} )) {
        # handle the refunc command
        autoload -Uz -- git-bid-refunc
        git-bid-refunc "$@"
        return $status
    } else {
        # execute the normal entrypoint
        autoload -Uz -- git-bid-entrypoint
        git-bid-entrypoint "$@"
    }

    _bid-lg-trace "total time in git-bid: $(( $SECONDS - $start_time ))"
    _bid-lg-trace "status: $status"

    return "$status"
    print -Pu2 "%F{red}post git-bid-entrypoint%F{reset}"
}

# ------------------------------- git-bid-setup ------------------------------ #
(( $+functions[git-bid-setup] )) || function git-bid-setup() {
    setopt re_match_pcre
    zmodload zsh/pcre

    (( $+GIT_BY_ID__SETUP_COMPLETE )) && return 0
    : "${GIT_BY_ID__SETUP_START:=${EPOCHREALTIME:-1}}"
    
    # set up completions
    (( $+functions[compdef] )) && compdef git-bid=git git-by-id=git

    (( !$+GIT_BY_ID__GIT_CMD )) && {
        # the underlying git command name, "git" by default
        # the git command will be found via $commands[${GIT_BY_ID__GIT}]
        : "${GIT_BY_ID__GIT:=git}"

        # require git binary actually exists
        if (( !$+commands[${GIT_BY_ID__GIT}] )) {
            print -Pu2 "%F{red}can not find git command '${GIT_BY_ID__GIT}'%f"
            return 1
        }
    }

    # full path to the git command, this path is what is actually used byt git-by-id
    : "${GIT_BY_ID__GIT_CMD:=$commands[$GIT_BY_ID__GIT]}"

    # log lots of output, options are
    #   4 - trace
    #   3 - debug
    #   2 - info
    #   1 - warn
    #   0 - error
    #   -1 print (used for full silent)
    # per command verbosity levels via GIT_BY_ID[VERBOSITY__git-<COMMAND>]
    : "${GIT_BY_ID__VERBOSITY:=2}"

    # enable color
    : "${GIT_BY_ID__NO_COLOR:=0}"
    : "${GIT_BY_ID__EXTRA_COLOR:=0}"

    # debug log of every git-by-id command
    : "${GIT_BY_ID__LOG_COMMANDS:=0}"

    # show numerical expansions when they happen
    : "${GIT_BY_ID__LOG_EXPANSIONS:=1}"

    # location to dump a history of unwrapped commands
    : "${GIT_BY_ID__LOGFILE:=/usr/local/var/log/git-bid.log}"

    # should id variables (`g23`, etc.) be set when creating the ids
    : "${GIT_BY_ID__SET_ID_VARS:=1}"
    
    # the git id variable prefix, defaults to "g"
    : "${GIT_BY_ID__PREFIX_VAR:=g}"

    # autocorrect when you combine creating a new branch with a commit message
    #    git checkout -b '[some feature] some message'
    # becomes
    #    git checkout -b some_feature/next
    #    git commit -m '[some feature] some message'
    : "${GIT_BY_ID__AUTOCORRECT_COMMIT_OOPS_BRANCH:=1}"

    # Checkout a branch if it already exists.
    : "${GIT_BY_ID__AUTOCORRECT_BRANCH_ALREADY_EXISTS:=1}"

    # Enable autoincrementing branch names
    #    git checkout -b some-branch/next
    # becomes
    #    git checkout -b some-branch/1
    : "${GIT_BY_ID__BRANCH_NEXT_TO_NUMBER:=1}"

    # Replace "master" in commands with "main" for modern repos
    : "${GIT_BY_ID__COERSE_TO_MAIN:=1}"

    # Confirm pushes to main branch
    : "${GIT_BY_ID__CONFIRM_PUSH_TO_MAIN:=1}"

    # Alias <cmd>i for interactive mode where supported. e.g. addi -> add --interactive
    : "${GIT_BY_ID__INTERACTIVE_I:=1}"

    # Defalt options to add to all fzf calls
    : "${GIT_BY_ID__FZF_DEFAULT_OPTS:=}"

    # prefix for log lines
    # 
    #   level       - long form name (trace, debug, info, warn, error)
    #   lvl         - short level name (trc, dbg, inf, wrn, err)
    #   now         - $EPOCHSECONDS
    #   file_line   - ${funcfiletrace:t}
    : "${GIT_BY_ID__LOG_FORMAT_TRACE:="%lvl %file_line -- %msg"}"
    : "${GIT_BY_ID__LOG_FORMAT_DEBUG:="%lvl %file_line -- %msg"}"
    : "${GIT_BY_ID__LOG_FORMAT_INFO:="%msg"}"
    : "${GIT_BY_ID__LOG_FORMAT_WARN:="%lvl %file_line -- %msg"}"
    : "${GIT_BY_ID__LOG_FORMAT_ERROR:="%lvl %file_line -- %msg"}"
    typeset -A GIT_BY_ID__LOG_LEVELS=(
        [trace]=trc
        [debug]=dbg
        [info]=inf
        [warn]=wrn
        [error]=err
    )

    # setup the theme
    local _theme=(
        'default=%F{default}'

        'git-del=%F{red}-'
        'git-new=%F{green}%B+%b'
        'git-both=%F{magenta}%B~%b%F{red}'
        'git-mod=%F{yellow}+'

        # characters
        'ob=%F{black}['     # open bracket
        'cb=%F{black}]'     # close bracket
        'arrow_full=%F{magenta}  --> %F{yellow}' # the arrow
        'arrow_phat=%F{magenta}  ==> %F{yellow}' # the arrow

        # colors by what they do
        'id=%F{white}'      # ids/nubmers
        'path=%F{white}'    # paths
        'arrow=%F{magenta}' # arrow color
        'ok=%F{green}'      # good
        'warn=%F{#FFA500}'  # bad
        'error=%F{red}'     # ugly
        'replace_left=%F{magenta}'  # text that is being changed
        'replace_right=%F{green}'   # what text is being changed to
        'replace_white=%F{white}'   # what goes arround and inbetween

        #log colors
        '_bid-lg-trace=%F{black}'
        '_bid-lg-debug=%F{black}'
        '_bid-lg-info=%F{white}'
        '_bid-lg-warn=%F{#FFA500}'
        '_bid-lg-error=%F{red}%B'
        '_bid-lg-reset=%f%b'

        # colors by name
        'black=%F{black}'
        'red=%F{red}'
        'green=%F{green}'
        'yellow=%F{yellow}'
        'blue=%F{blue}'
        'magenta=%F{magenta}'
        'cyan=%F{cyan}'
        'white=%F{white}'
        'bold=%B'
        'unbold=%b'
        'reset=%f'
    )

    : "${GIT_BY_ID__THEME:=${(j@:@)_theme}}"

    for segment in ${(s@:@)GIT_BY_ID__THEME} ; {
        if [[ "$segment" =~ "^([a-z-_]+)=(.*)$" ]] {
            local key=${match[1]//-/_}
            if (( $GIT_BY_ID__NO_COLOR )) {
                segment=$segment
                # ${segment:gs/%F{\*\}//}
                # TODO: support NO_COLOR
                # need to strip %F\{.*\},%f,%B,%b
                typeset -gx GIT_BY_ID__THEME_${key}=""
            } else {
                typeset -gx GIT_BY_ID__THEME_${key}="${match[2]}"
            }
            
        } else {
            print -u2 "'$segment' is an invalid theme option"
        }
    }
    # check to see if git is using a custom pager
    # GIT_BY_ID__COLOR_PAGER=0
    # [[ "$($commands[${GIT_BY_ID__GIT}] config --get core.pager 2>/dev/null)" =~ 'git-bid-color' ]] && GIT_BY_ID__COLOR_PAGER=1

    # set up git alias unpacking
    # this makes it so if you have an alias of `alias.st=status` then `git-by-id st` will know you mean `status`
    local key='' _aliases=$($GIT_BY_ID__GIT_CMD config --get-regexp alias | cat)
    function find-alias() {
        local alias_cmd="GIT_BY_ID__ALIAS_$1"
        [[ -v $alias_cmd ]] && {
            # print -u2 "found alias: $alias_cmd"
            find-alias "${(P)alias_cmd}"
        } || {
            # print -u2 "no alias: $1"
            print -- $1
        }
    }
    for a in ${(f)_aliases} ; {
        # print -u2 "alias: $a"
        # looks for simple aliases and alias functions with a well formed `: git <cmd>` as the first statement
        # e.g.
        #   alias.st=status
        #   alias.st=! git status
        #   alias.st= !"f(){ : git status } ; f"
        if [[
            "$a" =~ '^alias.(\w+)\s+([-\s\w]+)' \
            || "$a" =~ '^alias.([-\w]+)\s+!.*:\s*git\s+([-\s\w]+)'
            || "$a" =~ '^alias.([-\w]+)\s+!\s*git\s+([-\s\w]+)'
        ]] {
            # print -u2 "match: $a"
            local \
                alias_name="GIT_BY_ID__ALIAS_${match[1]//-/_}" \
                alias_value=${(MS)match[2]##[[:graph:]]*[[:graph:]]}
            typeset -gx $alias_name="${alias_value}"
        } else {
            # print -u2 "skip $a"
        }
    }
    local _aliases=($(typeset +m 'GIT_BY_ID__ALIAS_*'))
    for key in $_aliases ; {
        typeset -gx $key="$(find-alias ${key#GIT_BY_ID__ALIAS_*})"  # use find-alias to recursively unpack aliases
    }

    # mark time that setup completes (1 if EPOCHREALTIME is disabled)
    : "${GIT_BY_ID__SETUP_COMPLETE:=${EPOCHREALTIME:-1}}"

    # freeze settings
    # global export read-only match
    typeset -gxrm 'GIT_BY_ID__*'
    typeset -gx +r GIT_BY_ID__VERBOSITY

    if (( ${__trace__:-0} > 0 )) {
        local s settings=( ${(@f)${"$(typeset -m 'GIT_BY_ID__*')"}} )
        for s in ${(@on)settings} ; {
            print -Pu2 "%F{yellow}$s%f"
        }
    }

    # proactively source the file before continuing
    # this loads all the functions and enables faster loading of the commands
    # in subsequent runs this will speed up execution
    # [[ -e "$functions_source[git-by-id]" ]] && builtin source $functions_source[git-by-id]

    local \
        bid_funcs=(
            ${(k)functions[(I)git-by-id]}
            ${(k)functions[(I)git-bid-*]}
        ) \
        bid_util_funcs=(
            ${(k)functions[(I)_bid-*]}
        )
    autoload -Uz -- $bid_funcs $bid_util_funcs
    print -u2 "git-by-id: setup complete at ${GIT_BY_ID__SETUP_COMPLETE}"
}

# -------------------------------- entrypoints ------------------------------- #
(( $+functions[git-bid-entrypoint] )) || function git-bid-entrypoint() {
    # git <git-bid-options> COMMAND <git-options>
    # this zparseopts only parses out options before the git command/alias (hence no -E)
    local flag_v flag_q flag_level
    # these opts are removed from $@ for Git
    # TODO: correctly handle passing --verbose and --quiet
    zparseopts -D -E -- \
        v+=flag_v -verbose+=flag_v \
        q+=flag_q -quiet+=flag_q \
        -trace=flag_level -debug=flag_level -info=flag_level \
        -warn=flag_level -error=flag_level -silent=flag_level \

    # set up local verbosity variable for this invocation
    # verbosity is checked in the following order
    #   1. cli args
    #   2. GIT_BY_ID_VERBOSITY
    #   3. GIT_BY_ID__VERBOSITY
    local -i _GIT_BY_ID_VERBOSITY=${GIT_BY_ID_VERBOSITY:-$GIT_BY_ID__VERBOSITY}
    case 1 in
    $(( __line_trace__ ))) flag_level[1]=--trace ;;
    $(( __trace__ ))) flag_level[1]=--trace ;;
    $(( __debug__ ))) flag_level[1]=--debug ;;
    $(( __info__ ))) flag_level[1]=--info ;;
    $(( __warn__ ))) flag_level[1]=--warn ;;
    $(( __error__ ))) flag_level[1]=--error ;;
    $(( __silent__ ))) flag_level[1]=--silent ;;
    esac
    [[ "$flag_v" || "$flag_q" ]] && (( _GIT_BY_ID_VERBOSITY = $#flag_v - $#flag_q ))
    [[ "$flag_level" ]] && case "${flag_level[1]}" {
        --trace) _GIT_BY_ID_VERBOSITY=4 ;;
        --debug) _GIT_BY_ID_VERBOSITY=3 ;;
        --info) _GIT_BY_ID_VERBOSITY=2 ;;
        --warn) _GIT_BY_ID_VERBOSITY=1 ;;
        --error) _GIT_BY_ID_VERBOSITY=0 ;;
        --silent) _GIT_BY_ID_VERBOSITY=-1 ;;
    }
    _bid-lg-debug "set verbosity to $_GIT_BY_ID_VERBOSITY"

    local start_time=$SECONDS

    # run the function like normal!
    export LINES
    # disable color for now
    if (( GIT_BY_ID__EXTRA_COLOR && $+functions[git-bid-color] )) {
        # run output through a fancy colorizer (but its kinda broken)
        if [[ "$1" == diff ]] {
            # git-bid "$@" 2> >(git-bid-color stderr)
            return $status
        } elif (( $+functions[git-bid-color] )) {
            # git-bid "$@" > >(git-bid-color stdout) 2> >(git-bid-color stderr)
            return $status
        }
    } else {
        # run git-bid
        git-bid "$@"
        return $status
    }
    _bid-lg-trace "total time in git-bid: $(( $SECONDS - $start_time ))"
    return $status
}

(( $+functions[git-bid-refunc] )) || function git-bid-refunc() {
    setopt re_match_pcre
    zmodload zsh/pcre

    print -Pu2 "%F{red}re-sourcing all of git-by-id and supporting functions%F{reset}"
    set -- ${@:#refunc}

    local _GIT_BY_ID_VERBOSITY=2
    [[ "$@" =~ --trace ]] && local _GIT_BY_ID_VERBOSITY=4
    [[ "$@" =~ --quiet ]] && local _GIT_BY_ID_VERBOSITY=-5

    local start_setup="${GIT_BY_ID__SETUP_COMPLETE}"

    local \
        arrow=$GIT_BY_ID__THEME_arrow_full \
        pharrow=$GIT_BY_ID__THEME_arrow_phat \
        yellow=$GIT_BY_ID__THEME_yellow \
        white=$GIT_BY_ID__THEME_white \
        reset=$GIT_BY_ID__THEME_reset \
        sources=("${functions_source[git-by-id]}") \

    local \
        list_arrow="\n+>       $white- $yellow"

    # ---------------------------------- header ---------------------------------- #
    _bid-lg-print "%B${GIT_BY_ID__THEME_yellow}>>>>> scrubbing git-by-id environment%b${GIT_BY_ID__THEME_reset}"
    _bid-lg-trace "$arrow args: $@"
    _bid-lg-trace "$arrow shell pid: $$"
    _bid-lg-print "$pharrow cleaning config$reset"

    (( $#sources )) && {
        for line in ${(f)"$(shasum $sources)"} ; {
            [[ $line =~ '^([a-z0-9]+) (.*)$' ]] \
                && _bid-lg-print "$arrow ${match[1][1,8]} $white${(D)match[2]}$reset" \
                || _bid-lg-print "$line"
        }
    }

    # -------------------------------- clean vars -------------------------------- #
    # the variable unsetting must be done at the root level of the file

    # all the functions loaded as a part of git-by-id, used during the teardown
    # this config option has no default or ability to override

    typeset +r GIT_BY_ID    # make it readable
    local \
        key= \
        unset_vars=(
            GIT_IDS_COUNT
            GIT_IDS_LAST_RUN
            GIT_IDS
            GIT_BY_ID
            GIT_IDS_STAGED
            GIT_IDS_UNMERGED
            GIT_IDS_UNSTAGED
            GIT_IDS_UNTRACKED
            GIT_IDS_BRANCHES
        ) \
        bid_funcs=(
            ${(k)functions[(I)git-by-id]}
            ${(k)functions[(I)git-bid-*]}
        ) \
        bid_util_funcs=(
            ${(k)functions[(I)_bid-*]}
        ) \
        refunc_status=0

    # print the vars to scrub
    _bid-lg-print "$arrow cleaning variables$reset" $list_arrow${(on)^unset_vars}"$reset"
    typeset +r -x $unset_vars || refunc_status=1
    unset $unset_vars || refunc_status=1

    _bid-lg-print "$arrow cleaning prefix variables$reset" $list_arrow"${GIT_BY_ID__PREFIX_VAR}[0-9]##"
    unset -m "${GIT_BY_ID__PREFIX_VAR}[0-9]##" || refunc_status=1

    _bid-lg-print "$arrow cleaning config variables$reset" $list_arrow"GIT_BY_ID__*"
    typeset +r -xm 'GIT_BY_ID__*' || refunc_status=1
    unset -m 'GIT_BY_ID__*' || refunc_status=1

    # ------------------------------ clean functions ----------------------------- #
    _bid-lg-print "$arrow unloading functions$white:" "$list_arrow"${(on)^bid_funcs}"$reset"
    unfunction $bid_funcs || refunc_status=1

    # -------------------------- autoload for next time -------------------------- #
    _bid-lg-print "$arrow autoloading git-by-id$reset"
    autoload -Uz -- git-by-id || refunc_status=1

    # ------------------------- final logging and cleanup ------------------------ #
    # temporaraly reload print functions
    autoload -Uz -- _bid-lg-print _bid-lg-trace

    local end_setup="${GIT_BY_ID__SETUP_COMPLETE:-0}"

    if [[ "$start_setup" == "$end_setup" ]] {
        # check to see if the setup time was reset
        refunc_status=1
        _bid-lg-trace "teardown failed, GIT_BY_ID not reset"
        _bid-lg-trace "$start_setup should not equal $end_setup"
        _bid-lg-trace "shell pid: $$"
    } else {
        _bid-lg-trace "teardown complete"
    }

    _bid-lg-print "%B${GIT_BY_ID__THEME_yellow}<<<<< scrubbing git-by-id environment complete %b${GIT_BY_ID__THEME_reset}"

    # remove all functions again (to catch the logging functions we just used) but not git-by-id which we just loaded
    unfunction ${bid_util_funcs} 2>/dev/null || true

    return $refunc_status
}

# ---------------------------------------------------------------------------- #
#                                   Git By Id                                  #
# ---------------------------------------------------------------------------- #
(( $+functions[git-bid] )) || function git-bid() {
    (( ${__line_trace__:-0} )) && set -x || set +x  # turn on full tracing of the git command
    _bid-lg-trace "git-bid ${(qqqq)@}"

    local \
        extra_args=() \
        cmd="$GIT_BY_ID__GIT_CMD" \
        unwrapped_cmd \
        branch \
        interactive \
        one="$1" one_no_i="${1%i}" \
    
    zparseopts -D -E \
        -interactive=interactive \

    (( $GIT_BY_ID__LOG_COMMANDS )) && {
        # logs all git-bid commands to a log
        print "[$(date)] git-bid $@" >> $GIT_BY_ID__LOGFILE
    }

    # unwrap the cmd to see if it is an alias, then use that for 
    _bid-lg-trace GIT_BY_ID__ALIAS_$one=${(P)${:-GIT_BY_ID__ALIAS_$one}}
    if [[ -n ${(P)${:-GIT_BY_ID__ALIAS_$one}} ]] {
        unwrapped_cmd=${(P)${:-GIT_BY_ID__ALIAS_$one}}
        _bid-lg-trace "unwrapped '$one' to '$unwrapped_cmd' (via $GIT_BY_ID__ALIAS_$one)"
    } elif [[ -n ${(P)${:-GIT_BY_ID__ALIAS_$one_no_i}} ]] {
        unwrapped_cmd=${(P)${:-GIT_BY_ID__ALIAS_$one_no_i}}
        _bid-lg-trace "unwrapped '$one' to '$unwrapped_cmd'"
    } elif (
        (( $GIT_BY_ID__INTERACTIVE_I )) \
        && [[ "$one_no_i" != "$one" ]] \
        && (( $+functions[git-bid-fzf-$one_no_i] || $+functions[git-bid-fzf-$unwrapped_cmd] )) \
    ) {
        _bid-lg-fixup green git replace_left $one -\> green git replace_right "$one_no_i"
        one="$one_no_i"  # trim i off the end
        unwrapped_cmd="$one_no_i"
        (( ! $extra_args[(Ie)--byid-interactive] )) && extra_args+=(--byid-interactive)
        _bid-lg-trace "interactive unwrapped '$one' to '$unwrapped_cmd'"
    } else {
        _bid-lg-trace "'$one' is not wrapped"
        unwrapped_cmd="$one"
    }

    if [[ "$one" != "$unwrapped_cmd" ]] && {
        _bid-lg-fixup green git replace_left $one -\> green git replace_right $unwrapped_cmd
        # don't do this, it will eat the alias!
        # set - $unwrapped_cmd ${@[2,-1]} 
    }

    if [[ "$interactive" ]] {
        # only add if it wasn't already there
        (( ! $extra_args[(Ie)--byid-interactive] )) && extra_args+=(--byid-interactive)
    }

    case "$unwrapped_cmd" {
        (*by-id-setup)
            # run setup
            git-bid-shell-usage
            ;;
        (t | git)
            # handle funny cases of `gi t<cmd>` or `git git <cmd>`
            git-bid-tgit "$@"
            ;;
        (stash)
            git-bid-stash "$@"
            ;;
        (status)
            git-bid-number "${@[2,-1]}"
            ;;
        (commit | add | merge | mv)  # add verbose args
            extra_args+=--verbose
            ;&
        (commit | blame | add | log | rebase | merge | difftool)
            git-bid-number-expand --byid-execute $cmd $one $extra_args "${@:2}"
            ;;
        (rm | reset )
            extra_args+=--byid-skip-p-exits-check
            ;&
        (diff | rm | reset)
            git-bid-number-expand --byid-execute --byid-relative $cmd $extra_args "$@"
            ;;
        (checkout)  # branch orenited things
            git-bid-checkout "$@"
            ;;
        (branch)
            git-bid-number-branch $extra_args "${@:2}"
            ;;
        (next)
            # git next BRANCH_BASE EXTRA_PHRASE
            [[ "$2" ]] || {print -u2 "need a branch name" ; return 1}
            local phrase=("$2-next" "${3// /-}")
            _bid-lg-cmd git checkout -b "${(@j:-:)phrase:#}"
            ;;
        (fork)
            gh repo fork "${@:2}"
            ;;

        (push)
            git-bid-push "$@"
            ;;
        # (refunc|bid-refunc)
        #     # usually this is caught above
        #     git-bid-teardown "$@"
        #     ;;
        # (unfunc|bid-unfunc)
        #     git-bid-teardown --no-setup
        #     ;;
        (*)
            (( $+commands[git-$one] || $+functions[git-$one] )) && {
                # run custom git-* commands directly
                cmd="git-$one" ; shift
            }
            _bid-lg-cmd $cmd "$@"
            return $status
            ;;
    }
    return $status
}

# ----------------------------------- utils ---------------------------------- #
(( $+functions[git-bid-splitup] )) || function git-bid-splitup() {
    # split up this file into several function files
    setopt re_match_pcre
    zmodload zsh/pcre

    pcre_compile -m '^\(\( \$\+functions\[.*\] \)\) \|\| (?P<full>function (?P<name>.*)\(\) (?P<body>\{\n(.*\n)+?^\}))'
    local \
        MATCH \
        match \
        accum=() \
        string=$( cat $functions_source[$0] ) \
        bounds \
        name \
        body \

    functions_dir=${functions_source[$0]:h}/functions
    print $functions_dir
    [[ -d $functions_dir ]] || return 1
    rm --interactive $functions_dir/*

    pcre_match -b -- $string
    while [[ $? -eq 0 ]] do
        bounds=($=ZPCRE_OP)
        accum+=$MATCH
        name=$match[2]
        print "splitting $name"
        print -r "#!/usr/bin/env zsh
${name}() ${match[3]}
" > "$functions_dir/$name"

        pcre_match -b -n $bounds[2] -- $string
    done
    # print -l $accum
}
(( $+functions[_bid-lg-use-color] )) || function _bid-lg-use-color() {
    # only use color if stdout is of type tty
    # [[ -t 1 ]]
    true
}
(( $+functions[_bid-lg] )) || function _bid-lg() {
    { local _rc=$status ; set +x } 2>/dev/null  # disable tracing for logging functions
    autoload -Uz -- _bid-lg-use-color
    if ( _bid-lg-use-color ) {
        # check if stdout is a tty
        builtin print -Pu2 "+> $@"
    } else {
        print -u2 'no color'
        builtin print -P "+> $@" | \
            sed -r "s/[[:cntrl:]]\[[0-9]{1,3}m//g" \
            >&2
    }
    return $_rc
}
(( $+functions[_bid-lg-inspect] )) || function _bid-lg-inspect() {
    { local _rc=$status ; set +x } 2>/dev/null  # disable tracing for logging functions
    (( _GIT_BY_ID_VERBOSITY >= 4 )) && _bid-lg "%F{black}inspect+> $@%f"
    IFS="\n" && for line in $(cat -) ; do
        _bid-lg "%F{black}inspect>> $line%f"
        print -- "$line"
    done
    return $_rc
}
(( $+functions[_bid-lg-format] )) || function _bid-lg-format() {
    # $1 = level
    #   level       - long form name (trace, debug, info, warn, error)
    #   lvl         - short level name (trc, dbg, inf, wrn, err)
    #   now         - $EPOCHSECONDS
    #   file_line   - ${${funcfiletrace[2]}:t}
    autoload -Uz -- _bid-lg
    local \
        level=$1 \
        lvl=$GIT_BY_ID__LOG_LEVELS[$1] \
        args=${@[2,-1]} \
        color=${(P)${:-GIT_BY_ID__THEME__bid_lg_$1}}

    msg=${(P)${:-GIT_BY_ID__LOG_FORMAT_${(U)level}}}
    msg=${msg/\%level/$level}
    msg=${msg/\%lvl/$lvl}
    msg=${msg/\%file_line/${${funcfiletrace[2]}:t}}
    msg=${msg/\%now/$EPOCHSECONDS}
    msg=${msg/\%msg/$args}

    _bid-lg "${color}${msg}${GIT_BY_ID__THEME_reset}"
}
(( $+functions[_bid-lg-trace] )) || function _bid-lg-trace() {
    { local _rc=$status ; set +x } 2>/dev/null  # disable tracing for logging functions
    autoload -Uz -- _bid-lg-format
    (( _GIT_BY_ID_VERBOSITY >= 4 )) && _bid-lg-format trace $@
    return $_rc
}
(( $+functions[_bid-lg-debug] )) || function _bid-lg-debug() {
    { local _rc=$status ; set +x } 2>/dev/null  # disable tracing for logging functions
    autoload -Uz -- _bid-lg-format
    (( _GIT_BY_ID_VERBOSITY >= 3 )) && _bid-lg-format debug $@
    return $_rc
}
(( $+functions[_bid-lg-info] )) || function _bid-lg-info() {
    { local _rc=$status ; set +x } 2>/dev/null  # disable tracing for logging functions
    autoload -Uz -- _bid-lg-format
    (( _GIT_BY_ID_VERBOSITY >= 2 )) && _bid-lg-format info $@
    return $_rc
}
(( $+functions[_bid-lg-warn] )) || function _bid-lg-warn() {
    { local _rc=$status ; set +x } 2>/dev/null  # disable tracing for logging functions
    autoload -Uz -- _bid-lg-format
    (( _GIT_BY_ID_VERBOSITY >= 1 )) && _bid-lg-format warn $@
    return $_rc
}
(( $+functions[_bid-lg-error] )) || function _bid-lg-error() {
    { local _rc=$status ; set +x } 2>/dev/null  # disable tracing for logging functions
    autoload -Uz -- _bid-lg-format
    (( _GIT_BY_ID_VERBOSITY >= 0 )) && _bid-lg-format error $@
    return $_rc
}
(( $+functions[_bid-lg-print] )) || function _bid-lg-print() {
    { local _rc=$status ; set +x } 2>/dev/null  # disable tracing for logging functions
    autoload -Uz -- _bid-lg
    (( _GIT_BY_ID_VERBOSITY >= -1 )) && _bid-lg %"F{white}$@%f"
    return $_rc
}
(( $+functions[_bid-lg-fixup] )) || function _bid-lg-fixup() {
    { local _rc=$status ; set +x } 2>/dev/null  # disable tracing for logging functions
    local \
        _rc=$status \
        white=${GIT_BY_ID__THEME_white} \
        magenta=${GIT_BY_ID__THEME_magenta} \
        reset=${GIT_BY_ID__THEME_reset} \
        msg c

    while [[ "$@" ]] {
        c="$1" ; shift
        case $c {
            '[') msg="${msg%%[[:blank:]]##} ${white}$c$reset" ;;
            ']') msg="${msg%%[[:blank:]]##}${white}$c $reset" ;;
            '->') msg+="$white$c $reset" ;;
            '--') break ;;
            *)
                [[ -v GIT_BY_ID__THEME_$c ]] \
                    && msg+="${(P)${:-GIT_BY_ID__THEME_$c}}" \
                    || msg+="$c "
                ;;
        }
    }
    # strip whitespace
    msg=${${msg##[[:blank:]]##}%%[[:blank:]]##}

    # add brackets if missing
    if [[ ! "$msg" =~ '^\[.*\]$' ]] {
        msg="${white}[${msg}${white}]"
    } else {
        print 'has brackets'
    }

    # add any extra
    [[ "$@" ]] && msg+=" ${magenta}${@}"
    _bid-lg "$msg$reset"
    return $_rc
}
(( $+functions[_bid-lg-cmd] )) || function _bid-lg-cmd() {
    # helper to log a command to stderr
    { local _rc=$status ; set +x } 2>/dev/null  # disable tracing for logging functions
    local -i verbosity=0 v1=0 v2=0

    if [[ "$1" =~ '^-v|--verbose$' ]] {
        verbosity=2
        shift
    }

    if [[ "$1" == "$GIT_BY_ID__GIT_CMD" ]] {
        verbosity=0
    } else {
        # allow for per-git-command verbosity levels via GIT_BY_ID[VERBOSITY__git-<COMMAND>]
        ((
            v1=${_GIT_BY_ID_VERBOSITY:-0},
            v2=${GIT_BY_ID__VERBOSITY:-0},
            verbosity=verbosity > v1 ? verbosity : v1,
            verbosity=verbosity > v2 ? verbosity : v2
        ))
    }

    if (( verbosity == 1 )) {
        _bid-lg "%B$1%b ${@:2}"
    } elif (( verbosity == 2 )) {
        _bid-lg "%B$1%b ${(qqqq)@:2}"
    } else {
        _bid-lg-trace "%B$1%b ${(qqqq)@:2}"
    }

    "$@"
}

# ----------------------------- helper funcitons ----------------------------- #
(( $+functions[git-bid-color] )) || function git-bid-color() {
    setopt re_match_pcre
    zmodload zsh/pcre

    local u=0
    [[ "$1" == 'stderr' ]] && u=1
    while IFS= read -u$u -r line ; do
        # line=${line/origin/"%F{red}origin%f"}
        print -P "$line"
    done
    # while read -u$u -rd= line ; {

        # echo $line
        # line=${line/zmodload/"%F{red}zmodload%f"}
        # git
        # if [[ "$line" =~ "(CONFLICT)"] {
        #     RED(M1)
        # }
        # if [[ "$line" =~ "(fatal:)(.*)"] {
        #     BRIGHT_RED(M1)RED(M2)
        # }
        # if [[ "$line" =~ "(Continuing in [[:digit:].]+ seconds)"] {
        #     YELLOW(M1)
        # }
        # if [[ "$line" =~ "(Everything up-to-date)"] {
        #     GREEN(M1)
        # }
        
        # # pre-commit
        # if [[ "$line" =~ "(Passed)$"] {
        #     GREEN(M1)
        # }
        # if [[ "$line" =~ "(Skipped)$"] {
        #     YELLOW(M1)
        # }
        # if [[ "$line" =~ "(.*Failed)$"] {
        #     RED(M1)
        # }

        # # branches
        # if [[ "$line" =~ "(master)"] {
        #     MAGENTA(M1);
        # }
        # if [[ "$line" =~ "(main)"] {
        #     MAGENTA(M1);
        # }
    # }
    # gawk -i stdlib.awk -v outfile="/dev/$1" '
    # function foo(hello) { return "there"; }
    # function recolor(expression, colorize) { a = gensub(expression, colorize, "g", a); }
    # BEGIN {
    #     M1="\\1"
    #     M2="\\2"

    #     # git
    #     recolors["(CONFLICT)"] = RED(M1)
    #     recolors["(fatal:)(.*)"] = BRIGHT_RED(M1)RED(M2)
    #     recolors["(Continuing in [[:digit:].]+ seconds)"] = YELLOW(M1)
    #     recolors["(Everything up-to-date)"] = GREEN(M1)

    #     # pre-commit
    #     recolors["(Passed)$"] = GREEN(M1)
    #     recolors["(Skipped)$"] = YELLOW(M1)
    #     recolors["(.*Failed)$"] = RED(M1)

    #     # branches
    #     recolors["(master)"] = MAGENTA(M1);
    #     recolors["(main)"] = MAGENTA(M1);
    # }
    # {
    #     a = $0
    #     for (expr in recolors) {
    #         a = gensub(expr, recolors[expr], "g", a)
    #     }
    #     '$extra'
    #     print(a) > outfile;
    # }' -
}

(( $+functions[git-bid-config] )) || function git-bid-config() {
    local config_result="$(${GIT_BY_ID__GIT} config $@ 2>/dev/null)"
    if (( $status == 0 )) && [[ "$config_result" ]] {
        print "$config_result"
    } else {
        return $status
    }
}

(( $+functions[git-bid-shell-usage] )) || function git-bid-shell-usage() {
    # Setup for shell
    cat <<- EOF
	# add the following to an init script
	alias git="git-bid"
	alias gi="git"
	EOF
}


(( $+functions[git-bid-clean-vars] )) || function git-bid-clean-vars() {
    # reset the vairables used in each run
    typeset -g \
        GIT_IDS_COUNT=0 \
        GIT_IDS_LAST_RUN=${EPOCHREALTIME:-1}

    typeset -Ag \
        GIT_IDS=() \
        GIT_IDS_STAGED=() \
        GIT_IDS_UNMERGED=() \
        GIT_IDS_UNSTAGED=() \
        GIT_IDS_UNTRACKED=() \
        GIT_IDS_BRANCHES=()

    unset -m "${GIT_BY_ID__PREFIX_VAR}[0-9]##"
}

# ------------------------------- git-bid-tgit ------------------------------- #
(( $+functions[git-bid-tgit] )) || function git-bid-tgit() {
    # handle `gi t` and `git git`
    case "$1" {
        (t)
            if [[ "${2#t}" ]] {
                _bid-lg-fixup green gi error t magenta "${2#t}" -\> green git magenta "${2#t}" -- "${@:3}"
                git-bid "${2#t}" "${@:3}"
            } else {
                _bid-lg-fixup green gi error t -\> green git -- "${@:3}"
                git-bid "${@:3}"
            }
            ;;
        (git)
            _bid-lg-fixup green git error git magenta -\> green git -- "${@:2}"
            git-bid "${@:2}"
            ;;
    }
}

# -------------------------------- git-bid-fzf ------------------------------- #
(( $+functions[git-bid-fzf-handle-status-files] )) || function git-bid-fzf-handle-status-files() {
    zparseopts -D -E \
        -fzf-git-cmd:=git_cmd \
        -fzf-success-msg:=success_msg \
        -fzf-empty-msg:=empty_msg \
        -fzf-git-status=git_status \
        -fzf-extracter:=extracter \
        -u=untracked -untracked=untracked \

    local \
        empty_msg=${empty_msg[2]} \
        git_cmd=${git_cmd[2]} \

    if [[ $extracter ]] {
        extracter=${extracter[2]}
    } else {
        extracter="awk '{print \$2}'"
    }
    local preview="
        file=\$( echo {} | ${extracter} )
        if (git status -s -- \$file | grep '^??') &>/dev/null; then  # diff with /dev/null for untracked files
            git diff --color=always --no-index -- /dev/null \$file | sed '2 s/added:/untracked:/'
        else
            git diff --color=always origin/main -- \$file
        fi
    "
    local fzf_opts=(
        $GIT_BY_ID__FZF_DEFAULT_OPTS
        $GIT_BY_ID__FZF_ADD_OPTS
        -0 -m --nth 2..,..
        --ansi
        --preview $preview
        --multi
        --color header:italic
        --header "--> [git ${git_cmd}] (Shift-Tab to multi select)"
    )

    # get list of files for fzf
    local chosen=(
        $(
        git-bid status --short $untracked |
        sed '/^$/d' |
        fzf $fzf_opts |
        sh -c "${extracter}"
        )
    )

    if (( ${#chosen} > 0 )) {
        _bid-lg-cmd git ${git_cmd} $chosen
        local _exit_code=$status
        [[ "$git_status" ]] && git status
        return $_exit_code
    } else {
        print "${empty_msg}"
        return 1
    }
}

# ------------------------------ git-bid-fzf-add ----------------------------- #
(( $+functions[git-bid-fzf-add] )) || function git-bid-fzf-add() {
    git-bid-fzf-handle-status-files \
        --fzf-git-cmd add \
        --fzf-empty-msg "Nothing added." \
        "$@"
}

(( $+functions[git-bid-fzf-reset] )) || function git-bid-fzf-reset() {
    git-bid-fzf-handle-status-files \
        --fzf-git-cmd reset \
        --fzf-empty-msg "Nothing was reset." \
        "$@"
}

(( $+functions[git-bid-fzf-checkout] )) || function git-bid-fzf-checkout() {
    git-bid-fzf-handle-status-files \
        --fzf-git-cmd checkout \
        --fzf-empty-msg "Nothing was checked out." \
        "$@"
}

(( $+functions[git-bid-fzf-branch] )) || function git-bid-fzf-branch() {
    git-bid-fzf-handle-porcelain \
        --bid-list-command branch \
        --bid-list-args '-vv --all' \
        --bid-handle-command checkout \
        --bid-nothing-msg 'Nothing was checked out.' \
        --bid-no-multi \
        "$@"
}

# ------------------------------ git-bid-stash ------------------------------ #
(( $+functions[git-bid-stash] )) || function git-bid-stash() {
    if [[ $1 == stash && $2 == pop ]] {
        # handle stah pop -> git stash pop --quiet &&
        $cmd "$@" --quiet
        shift
    } elif [[ $1 == stash ]] {
        $cmd "$@"
        return $status
    }

    git-bid-number "${@[2,-1]}"
}

# ----------------------------- git-bid-checkout ----------------------------- #
(( $+functions[git-bid-checkout] )) || function git-bid-checkout() {
    setopt re_match_pcre
    zmodload zsh/pcre

    # index of argumets like '-b' or 'master'
    local \
        dash_b_index=${@[(i)-b]} \
        master_index=${@[(i)master]} \
        expand_args=()

    has_master_branch="$($GIT_BY_ID__GIT_CMD branch --list master)"
    has_main_branch="$($GIT_BY_ID__GIT_CMD branch --list main)"

    if (( ${GIT_BY_ID__COERSE_TO_MAIN} )) && [[ 
        "$master_index" -le ${#@}
        && -z "$has_master_branch"
        && "$has_main_branch"
    ]] {
        _bid-lg-fixup green git red master -\> green git magenta main -- "${@[3,-1]}"
        local args=($@)
        args[$master_index]="main"
        set - $args
    }

    # _bid-lg $dash_b_index
    if (( ${GIT_BY_ID__BRANCH_NEXT_TO_NUMBER} )) && [[ $dash_b_index -le ${#@} ]] {
        # check for -b group/project-next
        (( dash_b_index++ ))
        local co_branch=${@[$dash_b_index]}
        if [[ "$co_branch" =~ "next" ]] {
            local \
                group="$(whoami)" \
                project='' \
                flavor=''

            # support branch_name-next or next-branch_name
            if [[ "$co_branch" =~ ^(.*)/(.*)-next$ ]] {
                co_branch="${match[1]}/next-${match[2]}"
            } elif [[ "$co_branch" =~ ^(.*)-next$ ]] {
                co_branch="next-${match[1]}"
            }

            if [[ "$co_branch" =~ ^next-?(.*)$ ]] {
                flavor="$match[1]"
            } elif [[ "$co_branch" =~ ^(.*)/next-?(.*)$ ]] {
                group="$match[1]"
                flavor="$match[2]"
            } elif [[ "$co_branch" =~ ^(.*)/(.*)-next-?(.*)$ ]] {
                group="$match[1]"
                project="$match[2]"
                flavor="$match[3]"
            }
            local group_project=($group $project)
            local config_key="git-bid.${(j:-:)group_project:gs/_/-/}"
            local counter=${$(git-bid-config "$config_key"):-0}

            git-bid-config --replace-all --int "$config_key" $(( ++counter ))

            local project_counter_flavor=($project $counter $flavor)
            co_branch="$group/${(j:-:)project_counter_flavor}"

            _bid-lg-info "next branch: %F{magenta}$co_branch%f"

            local args=($@)
            args[$dash_b_index]="$co_branch"
            set - $args
        }
        expand_args+=(--byid-branch)
    }

    # run the git checkout command
    git-bid-number-expand --byid-execute $expand_args $cmd "$@"

    local co_status=$status
    case "$co_status" {
        ( 0 )
            return 0
            ;;
        ( 128 )
            _git-bid-handle-accidental-branch "$@"
            co_status=$status
            ;;
    }
    if (( co_status )) && [[ "$dash_b_index" && "$config_key" && "$counter" ]] {
        # decrement the counter if we failed to make the branch
        git-bid-config --replace-all --int "$config_key" $(( --counter ))
    }
    return $co_status
}

(( $+functions[_git-bid-handle-accidental-branch] )) || function _git-bid-handle-accidental-branch() {
    setopt re_match_pcre
    zmodload zsh/pcre

    # if status is 128 check to see if this was an "accidental branch creation"
    result=$(git-bid-number-expand --byid-execute --byid-branch $cmd "$@" 2>&1)
    if (( ${GIT_BY_ID__AUTOCORRECT_BRANCH_ALREADY_EXISTS} )) && [[ "$result" =~ "fatal: A branch named '(.*)' already exists" ]] {
        local branch="${match[1]}"
        local sleep_time=$(printf '%.1f' $(($(git-bid-config help.autocorrect) / 10.0)) )

        msg=(
            "${GIT_BY_ID__THEME_warn}WARNING%f: You tried to make a branch that already exists."
            "Continuing in $sleep_time seconds, assuming that you meant 'checkout'."
        )
        print -Pu2 -- "${(j:\n:)msg}"
        sleep $sleep_time

        _bid-lg-cmd $cmd $1 "$branch"
        return $status
    } elif (( ${GIT_BY_ID__AUTOCORRECT_COMMIT_OOPS_BRANCH} )) && [[ "$result" =~ "fatal: '\[(.*)\] (.*)' is not a valid branch name" ]] {
        local \
            message="[${match[1]}] ${match[2]}" \
            new_branch="${match[1]:gs/ /_/}/next-${match[2]:gs/ /-/}" \
            commit_msg="[${match[1]}] ${match[2]}" \
            sleep_time=$(printf '%.1f' $(($(git-bid-config help.autocorrect) / 10.0)) )

    } elif (( ${GIT_BY_ID__AUTOCORRECT_COMMIT_OOPS_BRANCH} )) && [[ "$result" =~ "fatal: '(.*)' is not a valid branch name" ]] {
        local \
            message="${match[1]}" \
            new_branch="${match[1]:gs/ /_/}-next" \
            commit_msg="${match[1]}" \
            sleep_time=$(printf '%.1f' $(($(git-bid-config help.autocorrect) / 10.0)) )
    } else {
        msg=(
            "${GIT_BY_ID__THEME_warn}WARNING%f: You tried to use a commit message for a branch name."
            "No new branch name could be autogenerated from the one provided."
        )
        print -Pu2 -- "${(j:\n:)msg}"
        return 1
    }

    msg=(
        "${GIT_BY_ID__THEME_warn}WARNING%f: You tried to use a commit message for a branch name."
        "Continuing in $sleep_time seconds assuming that you meant..."
        "    %F{green}git %F{magenta}checkout -b %F{white}\"%F{yellow}$new_branch%F{white}\"%f"
        "    %F{green}git %F{magenta}commit -am %F{white}\"%F{yellow}$commit_msg%F{white}\"%f"
    )
    print -Pu2 -- "${(j:\n:)msg}"
    sleep $sleep_time

    _bid-lg-cmd git-bid checkout -b "$new_branch" \
        && print -s -- "${GIT_BY_ID__GIT} commit -am \"$commit_msg\"" \
        && _bid-lg-cmd git-bid commit -am "$commit_msg"

    return $status
}

# ------------------------------- git-bid-push ------------------------------- #
(( $+functions[git-bid-push] )) || function git-bid-push() {
    setopt re_match_pcre
    zmodload zsh/pcre

    local _yes
    zparseopts -D -E -- y=_yes -yes=_yes
    if [[
        ${GIT_BY_ID__CONFIRM_PUSH_TO_MAIN} -eq 1
        && ! $_yes  # skip if -y or --yes is passed
        && -t 1     # check if fd1 is open for read
        && "$($cmd branch --show-current)" =~ '^(master|main)$'
    ]] {
        local should_push nl=$'\n'
        until [[ "${should_push:l}" =~ '(y|yes|n|no)$' ]] {
            read should_push\?"Push to ${match[1]}? [y/N]?${nl}> "
            [[ ${${should_push:-no}:l} =~ '^(n|no|exit)$' ]] && return 1
        }
    }
    $cmd $@
}

# ---------------------------------------------------------------------------- #
#                               number functions                               #
# ---------------------------------------------------------------------------- #

# ------------------------------- number expand ------------------------------ #
(( $+functions[git-bid-number-expand] )) || function git-bid-number-expand() {
    # Allows expansion of numbered shortcuts, ranges of shortcuts, or standard paths.
    # Return a string which can be `eval`ed like: eval args="$(scmb_expand_args "$@")"
    # Numbered shortcut variables are produced by various commands, such as:
    # * git_status_shortcuts()    - git status implementation
    # * git_show_affected_files() - shows files affected by a given SHA1, etc.
    
    setopt re_match_pcre
    zmodload zsh/pcre
    
    # Check for --relative param
    local \
        branch \
        execute \
        relative \
        skip_p_check \
        args=() \
        cmd \
        i \
        doublechecked=0

    zparseopts -E -D -- \
        -byid-branch=branch \
        -byid-execute=execute \
        -byid-relative=relative \
        -byid-skip-p-exits-check=skip_p_check \
        -byid-p-exists-in-index-ok=index_p_check \
        -byid-interactive=interactive \


    function prel() {
        # when no numbers are set re-check for numbers
        if (( !GIT_IDS_COUNT && !doublechecked++ )) {
            # (this can happen if git is being run in a subshell)
            [[ "$branch" ]] && cmd=git-bid-number-branch || cmd=git-bid-number
            _bid-lg-debug "running '${args[@]}' with no GIT_IDS_COUNT, checking for '$cmd'"
            $cmd
        }

        (( $+GIT_IDS[$1] )) || {
            _bid-lg-error "id [$1] hasn't been set yet"
            return 1
        }
        
        local p="${GIT_IDS[$1]}"
        [[ $relative ]] && p=${p#$PWD/}
        if \
            (( $+GIT_IDS_UNMERGED[$1] )) \
            || [[ "$skip_p_check" || "$branch" ]] \
        {
            _bid-lg-trace "skiping the p check"
            # just keep going, the branch/file doesn't need to exist or is known to be unmerged
        } elif [[ "$p" && ! -e "$p" ]] {
            # check if $p is a branch
            if ( $GIT_BY_ID__GIT_CMD rev-parse --quiet --verify "$p" >/dev/null ) {
                _bid-lg-trace "'$p' is a branch"
            } else {
                _bid-lg-error "'$p' doesn't seem to exist"
                return 1
            }
        }

        if (( ${GIT_BY_ID__LOG_EXPANSIONS} )) {
            _bid-lg-fixup replace_left $1 -\> replace_right $p
        } else {
            _bid-lg-trace "[$1] -> $p"
        }
        args+="$p"
    }

    setopt re_match_pcre
    for arg in "$@"; do
        _bid-lg-trace "arg: ${(qqqq)arg}"
        if [[ "$arg" =~ ^[0-9]{1,4}$ ]] {
            # Substitute $e{*} variables for any integers
            if [[ -e "$arg" ]] {
                # Don't expand files or directories with numeric names
                args+="$arg"
            } else {
                prel "$arg" || return $status
            }
        } elif [[ "$arg" =~ ^([0-9]{1,4})(?:[-,]|[.]{2})([0-9]{1,4})$ ]] {
            # Expand ranges into $e{*} variables
            # supports ranges like n,n | n-n | n..n
            for i in {$match[1]..$match[2]}; {
                prel $i || return $status
            }
        } else {
            # Otherwise, treat $arg as a normal string.
            args+="$arg"
        }
    done

    _bid-lg-trace "expanded args to: ${(qqqq@)args}"
    if [[ "$execute" && "$interactive" ]] && (( $+functions[git-bid-fzf-${@[2]}] )) {
        _bid-lg-cmd git-bid-fzf-${@[2]} "${(@)args}"
    } elif [[ "$execute" ]] {
        # "${(@)var}" to not re-parse spaces
        _bid-lg-cmd "${(@)args}"
        return $status
    } else {
        print -- "$args"
        return 0
    }

}

# ------------------------------- number branch ------------------------------ #
(( $+functions[git-bid-number-branch] )) || function git-bid-number-branch() {
    setopt re_match_pcre
    zmodload zsh/pcre
    git-bid-clean-vars
    GIT_IDS_COUNT=0

    # Fall back to normal git branch, if any unknown args given
    if (( $(${GIT_BY_ID__GIT} branch | wc -l) > 300 )) || [[ -n "$@" && "$@" != "-a" ]]; then
        git-bid-number-expand --byid-execute ${GIT_BY_ID__GIT} branch "$@"
        return $status
    fi

    #TODO add info about commit message: git log master..$branch --oneline | tail -1
    local branches branch= i=0
    branches=( ${(f)"$(${GIT_BY_ID__GIT} branch --color=always ${@})"} )
    for line in ${branches} ; {
        if [[ "$line" =~ "^([ *]{2})(.*)" ]] {
            branch="${match[2]}"
            print -P -- "${match[1]}${GIT_BY_ID__THEME_ob}${GIT_BY_ID__THEME_id}$((++i))${GIT_BY_ID__THEME_cb} ${match[2]}"
            # print -P $(git log --oneline master..$branch | tail -1)
        } else {
            _bid-lg-error "no match '$line'"
        }
    }


    # Set numbered file shortcut in variable
    for branch in $(IFS=$'\n' ${GIT_BY_ID__GIT} branch "$@" | sed "s/^[* ]\{2\}//"); do
        (( GIT_IDS_COUNT++ && GIT_BY_ID__SET_ID_VARS && GIT_BY_ID__SET_ID_VARS )) \
            && export $GIT_BY_ID__PREFIX_VAR$GIT_IDS_COUNT="$branch"
        GIT_IDS+=([$GIT_IDS_COUNT]="$branch")
        GIT_IDS_BRANCHES+=([$GIT_IDS_COUNT]="$branch")
    done
}

# ---------------------------------- number ---------------------------------- #
(( $+functions[git-bid-number] )) || function git-bid-number() {
    # Git status --porcelain output
    # X          Y     Meaning
    # -------------------------------------------------
    #          [AMD]   not updated
    # M        [ MD]   updated in index
    # A        [ MD]   added to index
    # D                deleted from index
    # R        [ MD]   renamed in index
    # C        [ MD]   copied in index
    # [MARC]           index and work tree matches
    # [ MARC]     M    work tree changed since index
    # [ MARC]     D    deleted in work tree
    # [ D]        R    renamed in work tree
    # [ D]        C    copied in work tree
    # -------------------------------------------------
    # D           D    unmerged, both deleted
    # A           U    unmerged, added by us
    # U           D    unmerged, deleted by them
    # U           A    unmerged, added by them
    # D           U    unmerged, deleted by us
    # A           A    unmerged, both added
    # U           U    unmerged, both modified
    # -------------------------------------------------
    # ?           ?    untracked
    # !           !    ignored
    # -------------------------------------------------
    setopt re_match_pcre
    zmodload zsh/pcre
    local \
        git_args=(-c color.status=always) \
        git_status=() \
        grouping \
        line section \
        output=() \
        quiet

    git-bid-clean-vars

    zparseopts -E -D -- q=quiet -quiet=quiet

    git_status=( "${(f@)$($GIT_BY_ID__GIT_CMD $git_args status "$@")}" )
    GIT_IDS_COUNT=0

    # local ob="${fg[black]}[$reset_color" cb="${fg[black]}]$reset_color"
    local \
        _ob="${GIT_BY_ID__THEME_ob}" \
        _cb="${GIT_BY_ID__THEME_cb}" \
        _id="${GIT_BY_ID__THEME_id}" \
        _del="${GIT_BY_ID__THEME_git_del}" \
        _new="${GIT_BY_ID__THEME_git_new}" \
        _both="${GIT_BY_ID__THEME_git_both}" \
        _mod="${GIT_BY_ID__THEME_git_mod}" \

    local ansi='\033\[[[:digit:]|;]*m'
    for line in "${(@)git_status}" ; {
        local match=() found_file=
        if [[ -z $line ]] {
        } elif [[ "$line" =~ "^($ansi)\s+\(.*\)" ]] {
        } elif [[ "$line" =~ 'Changes to be committed:' ]] {
            section=GIT_IDS_STAGED
        } elif [[ "$line" =~ 'Changes not staged for commit:' ]] {
            section=GIT_IDS_UNMERGED
        } elif [[ "$line" =~ 'Unmerged paths:' ]] {
            section=GIT_IDS_UNTRACKED
        } elif [[ "$line" =~ 'Untracked files:' ]] {
            section=GIT_IDS_UNTRACKED
        } elif [[ "$line" =~ "(\s+)($ansi)*(.*[deleted|both modified|modified|new file](?: by (?:us|them))?)(:)(\s+)(.*)$" ]] {
            local match_names=( lpad line_color kind colon rpad found_file ) i=0
            for (( i=1 ; i <= ${#match_names} ; i++ )) ; {
                local "${match_names[i]}"="$match[$i]"
                _bid-lg-trace "[$i] ${match_names[i]}=$match[$i]"
            }
            [[ "$line_color" ]] && _bid-lg-trace "$kind found a color => ${(q)line_color}' ${line_color}◘%f"
            case "$kind" {
                (deleted*)         kind="${_del}$line_color$kind" ;;
                (new*)            kind="${_new}$line_color$kind" ;;
                (both modified)   kind="${_both}$kind" ;;
                (modified)        kind="${_mod}$line_color$kind" ;;
                (*)               kind="?$line_color$kind" ; _bid-lg-warn "plz handle '$kind'" ;;
            }
            : $(( ++GIT_IDS_COUNT ))
            local id_pad="__id_pad_${#GIT_IDS_COUNT}"  # add padding to the number based on how many files we have seen
            line="$lpad$_ob$_id$GIT_IDS_COUNT$_cb$id_pad $kind$colon$line_color$rpad$found_file"
        } elif [[ "$line" =~ "(\t)(.*)" ]] {
            local lpad="$match[1]" found_file="$match[2]"
            line="$lpad$_ob$_id$(( ++GIT_IDS_COUNT ))$_cb $found_file"
        }

        output+="$line"

        if [[ "${found_file}" ]] {
            found_file="${found_file//$'\033'\[([0-9;])#m/}"
            GIT_IDS+=([$GIT_IDS_COUNT]="$found_file")
            typeset -x "${section}[$GIT_IDS_COUNT]"="$found_file"
            (( GIT_BY_ID__SET_ID_VARS )) && \
                export ${GIT_BY_ID__PREFIX_VAR}$GIT_IDS_COUNT="$found_file"
        }
    }

    if [[ ! "$quiet" && "$output" ]] {
        # escape ` in output, print -P was interpreting them
        output="${(j:\n:)output:gs/\`/\\\\\`/}\n"
        (( GIT_IDS_COUNT >= 10 )) && output=${output//__id_pad_1/__id_pad_2 }
        (( GIT_IDS_COUNT >= 100 )) && output=${output//__id_pad_2/__id_pad_3 }
        (( GIT_IDS_COUNT >= 1000 )) && output=${output//__id_pad_3/__id_pad_4 }
        (( GIT_IDS_COUNT >= 10000 )) && output=${output//__id_pad_4/ }
        output=${output//__id_pad_[0-9]/}

        print -nP -- "${output}"
    }
    return $(( !GIT_IDS_COUNT ))
}

-git-by-id $@
