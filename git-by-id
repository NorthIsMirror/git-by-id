#compdef git-bid=git
#!/usr/bin/env zsh
# code: language=zsh
setopt re_match_pcre
zmodload zsh/pcre
# ---------------------------------------------------------------------------- #
#                                   Git By Id                                  #
# ---------------------------------------------------------------------------- #


# ------------------------------- git-bid-setup ------------------------------ #
(( $+GIT_BY_ID[__SETUP__] )) || {
    # set up completions
    (( $+functions[compdef] )) && compdef git-bid=git git-by-id=git

    # Config map, set as global assoiative array
    typeset -Ag GIT_BY_ID

    (( !$+GIT_BY_ID[GIT_CMD] )) && {
        # the underlying git command name, "git" by default
        # the git command will be found via $commands[${GIT_BY_ID[GIT]}]
        : "${GIT_BY_ID[GIT]:=git}"

        # require git binary actually exists
        if (( !$+commands[${GIT_BY_ID[GIT]}] )) {
            print -Pu2 "%F{red}can not find git command '${GIT_BY_ID[GIT]}'%f"
            return 1
        }
    }

    # full path to the git command, this path is what is actually used byt git-by-id
    : "${GIT_BY_ID[GIT_CMD]:=$commands[$GIT_BY_ID[GIT]]}"

    # log lots of output, options are {0, 1, 2}
    # per command verbosity levels via GIT_BY_ID[VERBOSITY__git-<COMMAND>]
    : "${GIT_BY_ID[VERBOSITY]:=2}"

    # enable color
    : "${GIT_BY_ID[NO_COLOR]:=1}"
    : "${GIT_BY_ID[EXTRA_COLOR]:=0}"

    # debug log of every git-by-id command
    : "${GIT_BY_ID[LOG_COMMANDS]:=0}"

    # location to dump a history of unwrapped commands
    : "${GIT_BY_ID[LOGFILE]:=/usr/local/var/log/git-bid.log}"

    # should id variables (`g23`, etc.) be set when creating the ids
    : "${GIT_BY_ID[SET_ID_VARS]:=1}"
    
    # the git id variable prefix, defaults to "g"
    : "${GIT_BY_ID[PREFIX_VAR]:=g}"

    # autocorrect when you combine creating a new branch with a commit message
    #    git checkout -b '[some feature] some message'
    # becomes
    #    git checkout -b some_feature/next
    #    git commit -m '[some feature] some message'
    : "${GIT_BY_ID[AUTOCORRECT_COMMIT_OOPS_BRANCH]:=1}"

    # Checkout a branch if it already exists.
    : "${GIT_BY_ID[AUTOCORRECT_BRANCH_ALREADY_EXISTS]:=1}"

    # Enable autoincrementing branch names
    #    git checkout -b some-branch/next
    # becomes
    #    git checkout -b some-branch/1
    : "${GIT_BY_ID[BRANCH_NEXT_TO_NUMBER]:=1}"

    # setup the theme
    local _theme=(
        'ob=%F{black}['
        'cb=%F{black}]'
        'id=%F{white}'
        'git-del=%F{red}-'
        'git-new=%F{green}%B+%b'
        'git-both=%F{magenta}%B~%b%F{red}'
        'git-mod=%F{yellow}+'
        'arrow=%F{magenta}  --> %F{yellow}'
        'ok=%F{green}'
        'warn=%F{#FFA500}'
        'error=%F{red}'
    )

    : "${GIT_BY_ID[THEME]:=${(j@:@)_theme}}"

    for segment in ${(s@:@)GIT_BY_ID[THEME]} ; {
        if [[ "$segment" =~ "^([a-z-]+)=(.*)$" ]] {
            if (( $GIT_BY_ID[NO_COLOR] )) {
                segment=$segment
                # ${segment:gs/%F{\*\}//}
                # TODO: support NO_COLOR
                # need to strip %F\{.*\},%f,%B,%b
            }
            GIT_BY_ID[THEME_$match[1]]="${match[2]}"
        } else {
            print -u2 "'$segment' is an invalid theme option"
        }
    }
    # check to see if git is using a custom pager
    # GIT_BY_ID[COLOR_PAGER]=0
    # [[ "$($commands[${GIT_BY_ID[GIT]}] config --get core.pager 2>/dev/null)" =~ 'git-bid-color' ]] && GIT_BY_ID[COLOR_PAGER]=1

    # set up git alias unpacking
    # this makes it so if you have an alias of `alias.st=status` then `git-by-id st` will know you mean `status`
    local key='' _aliases=$($GIT_BY_ID[GIT_CMD] config --get-regexp alias)
    function find-alias() { (( $+GIT_BY_ID[ALIAS_$1] )) && find-alias "$GIT_BY_ID[ALIAS_$1]" || echo $1 }
    for a in ${(f)_aliases} ; {
        # looks for simple aliases and alias functions with a well formed `: git <cmd>` as the first statement
        [[ $a =~ '^alias.(\w+)\s+(\w+)' || $a =~ '^alias.(\w+)\s+!.*:\s*git\s+(\w+)' ]] \
            && GIT_BY_ID[ALIAS_${match[1]}]="${match[2]}"
    }
    for key in ${(k)GIT_BY_ID[(I)ALIAS_*]} ; {
        GIT_BY_ID[$key]="$(find-alias ${key#ALIAS_*})"  # use find-alias to recursively unpack aliases
    }

    # mark time that setup completes (1 if EPOCHREALTIME is disabled)
    : "${GIT_BY_ID[__SETUP__]:=${EPOCHREALTIME:-1}}"

    # freeze settings
    readonly -Ag GIT_BY_ID

    # proactively source the file before continuing
    # this loads all the functions and enables faster loading of the commands
    # in subsequent runs this will speed up execution
    [[ -e "$functions_source[git-by-id]" ]] && builtin source $functions_source[git-by-id]
}

# -------------------------------- entrypoints ------------------------------- #
(( $+functions[git-bid-entrypoint] )) && {
    # this short-cuts loading the rest of the file when already sourced
    git-bid-entrypoint "$@"
    return $status
} || function git-bid-entrypoint() {
    if [[ "$1" == 'refunc' ]] {
        xlg-cmd git-bid-teardown
        return $status
    } else {
        # run the function like normal!
        export LINES
        # disable color for now
        if (( GIT_BY_ID[EXTRA_COLOR] && $+functions[git-bid-color] )) {
            # run output through a fancy colorizer (but its kinda broken)
            if [[ "$1" == diff ]] {
                git-bid "$@" 2> >(git-bid-color stderr)
            } elif (( $+functions[git-bid-color] )) {
                git-bid "$@" > >(git-bid-color stdout) 2> >(git-bid-color stderr)
            }
        } else {
            # run git-bid
            git-bid "$@"
        }
        return $status
    }
}

(( $+functions[git-bid-teardown] )) || function git-bid-teardown() {
    local \
        arrow=$GIT_BY_ID[THEME_arrow] \
        sources=("${functions_source[git-by-id]}") \
        bid_funcs=(
            ${(k)functions[(I)git-by-id*]}
            ${(k)functions[(I)git-bid*]}
            ${(k)functions[(I)__git-bid*]}
        )

    xlg "%B%F{yellow}====> scrubbing git-by-id environment%b%f"


    xlg "$arrow cleaning config%f"
    typeset +r GIT_BY_ID
    (( $+GIT_BY_ID[__SETUP__] )) && GIT_BY_ID[__SETUP__]=

    xlg "$arrow cleaning variables%f"
    xlg-cmd git-bid-clean-vars

    xlg "$arrow unloading functions%F{white}:" "\n+> "'      %F{white}- %F{yellow}'${^bid_funcs}'%f'
    xlg-cmd unfunction $bid_funcs

    xlg "$arrow autoloading git-by-id%f"
    xlg-cmd autoload git-by-id

    [[ "$@" =~ '--no-setup' ]] && return
    
    xlg "$arrow force loading git-by-id%f"
    for line in ${(f)"$(shasum $sources)"} ; {
        if [[ $line =~ '^([a-z0-9]+) (.*)$' ]] {
            xlg "$arrow ${match[1][1,7]}%f %F{white}${match[2]}%f"
        } else {
            xlg  "$line"
        }
    }

    xlg-cmd builtin source "$sources"
}

# ---------------------------------------------------------------------------- #
#                                   Git By Id                                  #
# ---------------------------------------------------------------------------- #
(( $+functions[git-bid] )) || function git-bid() {
    (( ${__trace__:-0} )) && set -x || set +x

    # zparseopts -D -E -- \
    #     v+=flag_v -verbose+=flag_v \
    #     q+=flag_q -quiet+=flag_q

    # (( GIT_BY_ID_VERBOSITY = $#flag_v - $#flag_q ))

    local \
        extra_args=() \
        cmd="$GIT_BY_ID[GIT_CMD]" \
        unwrapped_cmd \
        branch

    (( $GIT_BY_ID[LOG_COMMANDS] )) && {
        # logs all git-bid commands to a log
        print "[$(date)] git-bid $@" >> $GIT_BY_ID[LOGFILE]
    }

    # unwrap the cmd to see if it is an alias, then use that for 
    unwrapped_cmd="${GIT_BY_ID[ALIAS_$1]:-$1}"
    [[ "$1" != "$unwrapped_cmd" ]] && {
        xlg "%F{white}[%F{green}git %F{magenta}$1 %F{white}-> %F{green}git %F{magenta}$unwrapped_cmd%F{white}]%f"
    }

    case "$unwrapped_cmd" {
        (*by-id-setup)
            # run setup
            git-bid-shell-usage
            ;;
        (t | git)
            # handle funny cases of `gi t<cmd>` or `git git <cmd>`
            git-bid-tgit "$@"
            ;;
        (stash)
            git-bid-stash "$@"
            ;;
        (status)
            git-bid-number "${@[2,-1]}"
            ;;
        (commit | add | merge )  # add verbose args
            extra_args+=--verbose
            ;&
        (commit | blame | add | log | rebase | merge | difftool)
            git-bid-number-expand --byid-execute $cmd $1 $extra_args "${@:2}"
            ;;
        (rm)
            extra_args+=--byid-remove
            ;&
        (diff | rm | reset)
            git-bid-number-expand --byid-execute --byid-relative $cmd $extra_args "$@"
            ;;
        (checkout)  # branch orenited things
            git-bid-checkout "$@"
            ;;
        (branch)
            git-bid-number-branch "${@:2}"
            ;;
        (next)
            # git next BRANCH_BASE EXTRA_PHRASE
            [[ "$2" ]] || {print -u2 "need a branch name" ; return 1}
            local phrase=("$2-next" "${3// /-}")
            xlg-cmd git checkout -b "${(@j:-:)phrase:#}"
            ;;
        (fork)
            gh repo fork "${@:2}"
            ;;

        (push)
            git-bid-push "$@"
            ;;
        (refunc|bid-refunc)
            git-bid-teardown
            ;;
        (unfunc|bid-unfunc)
            git-bid-teardown --no-setup
            ;;
        (*)
            (( $+commands[git-$1] || $+functions[git-$1] )) && {
                # run custom git-* commands directly
                cmd="git-$1" ; shift
            }
            xlg-cmd $cmd "$@"
            ;;
    }
    return $status
}

# ----------------------------------- utils ---------------------------------- #
(( $+functions[xlg] )) || function xlg() { print -Pu2 "+> $@" }
(( $+functions[xlg-trace] )) || function xlg-trace() { (( GIT_BY_ID[VERBOSITY] >= 3 )) && xlg "%F{black}$@%f" }
(( $+functions[xlg-debug] )) || function xlg-debug() { (( GIT_BY_ID[VERBOSITY] >= 2 )) && xlg "%F{black}$@%f" }
(( $+functions[xlg-info] )) || function xlg-info() { (( GIT_BY_ID[VERBOSITY] >= 1 )) && xlg "%F{black}$@%f" }
(( $+functions[xlg-print] )) || function xlg-print() { xlg %"F{white}$@%f" }
(( $+functions[xlg-warn] )) || function xlg-warn() { xlg %"F{yellow}$@%f" }
(( $+functions[xlg-error] )) || function xlg-error() { xlg %"F{red}%B$@%b%f" }

(( $+functions[xlg-cmd] )) || function xlg-cmd() {
    # helper to log a command to stderr
    local -i verbosity=0 v1=0 v2=0

    [[ "$1" =~ '-v|--verbose' ]] && {
        verbosity=2
        shift
    }

    # allow for per-git-command verbosity levels via GIT_BY_ID[VERBOSITY__git-<COMMAND>]
    ((
        v1=${GIT_BY_ID_VERBOSITY:-0},
        v2=${GIT_BY_ID[VERBOSITY]:-0},
        
        verbosity=verbosity > v1 ? verbosity : v1,
        verbosity=verbosity > v2 ? verbosity : v2
    ))

    if [[ "$1" == "$GIT_BY_ID[GIT_CMD]" ]] {
        verbosity=0
    }

    (( verbosity >= 1 )) && xlg "%B$1%b ${@:2}"

    "$@"
}

# ----------------------------- helper funcitons ----------------------------- #
(( $+functions[git-bid-color] )) || function git-bid-color() {
    local u=0
    [[ "$1" == 'stderr' ]] && u=1
    while IFS= read -u$u -r line ; do
        # line=${line/origin/"%F{red}origin%f"}
        print -P "$line"
    done
    # while read -u$u -rd= line ; {

        # echo $line
        # line=${line/zmodload/"%F{red}zmodload%f"}
        # git
        # if [[ "$line" =~ "(CONFLICT)"] {
        #     RED(M1)
        # }
        # if [[ "$line" =~ "(fatal:)(.*)"] {
        #     BRIGHT_RED(M1)RED(M2)
        # }
        # if [[ "$line" =~ "(Continuing in [[:digit:].]+ seconds)"] {
        #     YELLOW(M1)
        # }
        # if [[ "$line" =~ "(Everything up-to-date)"] {
        #     GREEN(M1)
        # }
        
        # # pre-commit
        # if [[ "$line" =~ "(Passed)$"] {
        #     GREEN(M1)
        # }
        # if [[ "$line" =~ "(Skipped)$"] {
        #     YELLOW(M1)
        # }
        # if [[ "$line" =~ "(.*Failed)$"] {
        #     RED(M1)
        # }

        # # branches
        # if [[ "$line" =~ "(master)"] {
        #     MAGENTA(M1);
        # }
        # if [[ "$line" =~ "(main)"] {
        #     MAGENTA(M1);
        # }
    # }
    # gawk -i stdlib.awk -v outfile="/dev/$1" '
    # function foo(hello) { return "there"; }
    # function recolor(expression, colorize) { a = gensub(expression, colorize, "g", a); }
    # BEGIN {
    #     M1="\\1"
    #     M2="\\2"

    #     # git
    #     recolors["(CONFLICT)"] = RED(M1)
    #     recolors["(fatal:)(.*)"] = BRIGHT_RED(M1)RED(M2)
    #     recolors["(Continuing in [[:digit:].]+ seconds)"] = YELLOW(M1)
    #     recolors["(Everything up-to-date)"] = GREEN(M1)

    #     # pre-commit
    #     recolors["(Passed)$"] = GREEN(M1)
    #     recolors["(Skipped)$"] = YELLOW(M1)
    #     recolors["(.*Failed)$"] = RED(M1)

    #     # branches
    #     recolors["(master)"] = MAGENTA(M1);
    #     recolors["(main)"] = MAGENTA(M1);
    # }
    # {
    #     a = $0
    #     for (expr in recolors) {
    #         a = gensub(expr, recolors[expr], "g", a)
    #     }
    #     '$extra'
    #     print(a) > outfile;
    # }' -
}

(( $+functions[git-bid-config] )) || function git-bid-config() {
    local config_result="$(${GIT_BY_ID[GIT]} config $@ 2>/dev/null)"
    if (( $status == 0 )) && [[ "$config_result" ]] {
        print "$config_result"
    } else {
        return $status
    }
}

(( $+functions[git-bid-shell-usage] )) || function git-bid-shell-usage() {
    # Setup for shell
    cat <<- EOF
	# add the following to an init script
	alias git="git-bid"
	alias gi="git"
	EOF
}


(( $+functions[git-bid-clean-vars] )) || function git-bid-clean-vars() {
    # reset the vairables used in each run
    typeset -g \
        GIT_IDS_COUNT=0 \
        GIT_IDS_LAST_RUN=${EPOCHREALTIME:-1}

    typeset -Ag \
        GIT_IDS=() \
        GIT_IDS_STAGED=() \
        GIT_IDS_UNMERGED=() \
        GIT_IDS_UNSTAGED=() \
        GIT_IDS_UNTRACKED=() \
        GIT_IDS_BRANCHES=()

    unset -m "${GIT_BY_ID[PREFIX_VAR]}[0-9]##"
}

# ------------------------------- git-bid-tgit ------------------------------- #
(( $+functions[git-bid-tgit] )) || function git-bid-tgit() {
    # handle `gi t` and `git git`
    local _g=$fg[green] _m=$fg[magenta] _w=$fg[white] _r=$fg[red] _rc=$reset_color \
        msg args

    [[ "${@:3}" ]] && local extra=" $_m${@:3}$_rc"
    case $1 {
        (t)
            msg="${_w}[${_g}gi ${_r}t${_m}${2#t} ${_w}-> ${_g}git ${_m}${2#t}${_w}]$_rc$extra$_rc"
            args=("${2#t}" "${@:3}")
            ;;
        (git)
            msg="${_w}[${_g}git ${_r}git ${_m}${2} ${_w}-> ${_g}git ${_m}${2}${_w}]$_rc$extra$_rc"
            args=("${@:2}")
            ;;
    }

    xlg "$msg"
    git-bid $args
}

# ------------------------------ git-bid-stash ------------------------------ #
(( $+functions[git-bid-stash] )) || function git-bid-stash() {
    if [[ $1 == stash && $2 == pop ]] {
        # handle stah pop -> git stash pop --quiet &&
        $cmd "$@" --quiet
        shift
    } elif [[ $1 == stash ]] {
        $cmd "$@"
        return $status
    }

    git-bid-number "$@[2,-1]"
}

# ----------------------------- git-bid-checkout ----------------------------- #
(( $+functions[git-bid-checkout] )) || function git-bid-checkout() {
    local bi  # -b index
    if (( ${GIT_BY_ID[BRANCH_NEXT_TO_NUMBER]} )) && [[ ${bi:=${@[(i)-b]}} -le ${#@} ]] {
        # check for -b group/project-next
        (( bi++ ))
        local co_branch=${@[$bi]}
        if [[ "$co_branch" =~ "next" ]] {
            local \
                group="$(whoami)" \
                project='' \
                flavor=''

            if [[ "$co_branch" =~ "^next-?(.*)$" ]] {
                flavor="$match[1]"
            } elif [[ "$co_branch" =~ "^(.*)/next-?(.*)$" ]] {
                group="$match[1]"
                flavor="$match[2]"
            } elif [[ "$co_branch" =~ "^(.*)/(.*)-next-?(.*)$" ]] {
                group="$match[1]"
                project="$match[2]"
                flavor="$match[3]"
            }

            local group_project=($group $project)
            local config_key="git-bid.${(j:-:)group_project:gs/_/-/}"
            local counter=${$(git-bid-config "$config_key"):-0}

            git-bid-config --replace-all --int "$config_key" $(( ++counter ))

            local project_counter_flavor=($project $counter $flavor)
            co_branch="$group/${(j:-:)project_counter_flavor}"

            xlg "next branch: %F{magenta}$co_branch%f"

            local args=($@)
            args[$bi]="$co_branch"
            set - $args
        }
    }

    # run the git checkout command
    git-bid-number-expand --byid-execute --byid-branch $cmd "$@"
    local co_status=$status
    case "$co_status" {
        ( 0 )
            return 0
            ;;
        ( 128 )
            __git-bid-handle-accidental-branch "$@"
            co_status=$status
            ;;
    }
    if (( co_status )) && [[ "$bi" && "$config_key" && "$counter" ]] {
        # decrement the counter if we failed to make the branch
        git-bid-config --replace-all --int "$config_key" $(( --counter ))
    }
    return $co_status
}

(( $+functions[__git-bid-handle-accidental-branch] )) || function __git-bid-handle-accidental-branch() {
    # if status is 128 check to see if this was an "accidental branch creation"
    result=$(git-bid-number-expand --byid-execute --byid-branch $cmd "$@" 2>&1)
    if (( ${GIT_BY_ID[AUTOCORRECT_BRANCH_ALREADY_EXISTS]} )) && [[ "$result" =~ "fatal: A branch named '(.*)' already exists." ]] {
        local branch="${match[1]}"
        local sleep_time=$(printf '%.1f' $(($(git-bid-config help.autocorrect) / 10.0)) )

        msg=(
            "${GIT_BY_ID[THEME_warn]}WARNING%f: You tried to make a branch that already exists."
            "Continuing in $sleep_time seconds, assuming that you meant 'checkout'."
        )
        print -Pu2 "${(j:\n:)msg}"
        sleep $sleep_time

        xlg-cmd $cmd $1 "$branch"
        return $status
    } elif (( ${GIT_BY_ID[AUTOCORRECT_COMMIT_OOPS_BRANCH]} )) && [[ "$result" =~ "fatal: '\[(.*)\] (.*)' is not a valid branch name." ]] {
        local \
            message="[${match[1]}] ${match[2]}" \
            new_branch="${match[1]:gs/ /_/}/next" \
            commit_msg="[${match[1]}] ${match[2]}" \
            sleep_time=$(printf '%.1f' $(($(git-bid-config help.autocorrect) / 10.0)) )

        msg=(
            "${GIT_BY_ID[THEME_warn]}WARNING%f: You tried to use a commit message for a branch name."
            "Continuing in $sleep_time seconds assuming that you meant..."
            "    %F{green}git %F{magenta}checkout -b %F{white}\"%F{yellow}$new_branch%F{white}\"%f"
            "    %F{green}git %F{magenta}commit -m %F{white}\"%F{yellow}$commit_msg%F{white}\"%f"
        )
        print -Pu2 "${(j:\n:)msg}"
        sleep $sleep_time

        xlg-cmd git-bid checkout -b "$new_branch" \
            && xlg-cmd git-bid commit -m "$commit_msg"
        return $status
    }
}

# ------------------------------- git-bid-push ------------------------------- #
(( $+functions[git-bid-push] )) || function git-bid-push() {
    if [[
        -t 1  # check if fd1 is open for read
        && "$($cmd branch --show-current)" =~ '(master|main)'
    ]] {
        local should_push nl=$'\n'
        until [[ "${should_push:l}" =~ '(y|yes|n|no)$' ]] {
            read should_push\?"Push to ${match[1]}? [y/N]?${nl}> "
            [[ ${${should_push:-no}:l} =~ '^(n|no|exit)$' ]] && return 1
        }
    }
    $cmd $@
}

# ---------------------------------------------------------------------------- #
#                               number functions                               #
# ---------------------------------------------------------------------------- #

# ------------------------------- number expand ------------------------------ #
(( $+functions[git-bid-number-expand] )) || function git-bid-number-expand() {
    # Allows expansion of numbered shortcuts, ranges of shortcuts, or standard paths.
    # Return a string which can be `eval`ed like: eval args="$(scmb_expand_args "$@")"
    # Numbered shortcut variables are produced by various commands, such as:
    # * git_status_shortcuts()    - git status implementation
    # * git_show_affected_files() - shows files affected by a given SHA1, etc.

    # Check for --relative param
    local \
        branch \
        execute \
        relative \
        remove \
        args=() \
        cmd \
        i \
        doublechecked=0

    zparseopts -E -D -- \
        -byid-branch=branch \
        -byid-execute=execute \
        -byid-relative=relative \
        -byid-remove=remove \


    function prel() {
        # when no numbers are set re-check for numbers
        if (( !GIT_IDS_COUNT && !doublechecked++ )) {
            # (this can happen if git is being run in a subshell)
            [[ "$branch" ]] && cmd=git-bid-number-branch || cmd=git-bid-number
            xlg-debug "running '${args[@]}' with no GIT_IDS_COUNT, checking for '$cmd'"
            $cmd
        }

        (( $+GIT_IDS[$1] )) || {
            xlg-error "id [$1] hasn't been set yet"
            return 1
        }
        
        local p="${GIT_IDS[$1]}"
        [[ $relative ]] && p=${p#$PWD/}

        if [[ "$remove" || "$branch" ]] {
            # just keep going, the branch/file doesn't need to exist
        } elif [[ "$p" && ! -e "$p" ]] {
            xlg-error "'$p' doesn't seem to exist"
            return 1
        }

        xlg-trace "[$1] -> $p"
        args+="$p"
    }

    setopt re_match_pcre
    for arg in "$@"; do
        xlg-trace "arg: $arg"
        if [[ "$arg" =~ ^[0-9]{1,4}$ ]] {
            # Substitute $e{*} variables for any integers
            if [[ -e "$arg" ]] {
                # Don't expand files or directories with numeric names
                args+="$arg"
            } else {
                prel $arg || return $status
            }
        } elif [[ "$arg" =~ ^([0-9]{1,4})(?:[-,]|[.]{2})([0-9]{1,4})$ ]] {
            # Expand ranges into $e{*} variables
            for i in {$match[1]..$match[2]}; {
                prel $i || return $status
            }
        } else {
            # Otherwise, treat $arg as a normal string.
            args+="$arg"
        }
    done

    cmd=( ${args[@]} )
    xlg-trace "expanded $cmd"
    if [[ "$execute" ]] {
        xlg-cmd $cmd
        return $status
    } else {
        print "$cmd"
        return 0
    }

}

# ------------------------------- number branch ------------------------------ #
(( $+functions[git-bid-number-branch] )) || function git-bid-number-branch() {
    git-bid-clean-vars

    # Fall back to normal git branch, if any unknown args given
    if (( $(${GIT_BY_ID[GIT]} branch | wc -l) > 300 )) || [[ -n "$@" && "$@" != "-a" ]]; then
        git-bid-number-expand --byid-execute ${GIT_BY_ID[GIT]} branch "$@"
        return $status
    fi

    #TODO add info about commit message: git log master..$branch --oneline | tail -1
    local branches branch= i=0
    branches=( ${(f)"$(${GIT_BY_ID[GIT]} branch --color=always ${@})"} )
    for line in ${branches} ; {
        if [[ "$line" =~ "^([ *]{2})(.*)" ]] {
            branch="${match[2]}"
            print -P "${match[1]}${GIT_BY_ID[THEME_ob]}${GIT_BY_ID[THEME_id]}$((++i))${GIT_BY_ID[THEME_cb]} ${match[2]}"
            # print -P $(git log --oneline master..$branch | tail -1)
        } else {
            xlg-error "no match '$line'"
        }
    }


    # Set numbered file shortcut in variable
    for branch in $(IFS=$'\n' ${GIT_BY_ID[GIT]} branch "$@" | sed "s/^[* ]\{2\}//"); do
        (( GIT_IDS_COUNT++ && GIT_BY_ID[SET_ID_VARS] && GIT_BY_ID[SET_ID_VARS] )) \
            && export $GIT_BY_ID[PREFIX_VAR]$GIT_IDS_COUNT="$branch"
        GIT_IDS+=([$GIT_IDS_COUNT]="$branch")
        GIT_IDS_BRANCHES+=([$GIT_IDS_COUNT]="$branch")
    done
}

# ---------------------------------- number ---------------------------------- #
(( $+functions[git-bid-number] )) || function git-bid-number() {
    # Git status --porcelain output
    # X          Y     Meaning
    # -------------------------------------------------
    #          [AMD]   not updated
    # M        [ MD]   updated in index
    # A        [ MD]   added to index
    # D                deleted from index
    # R        [ MD]   renamed in index
    # C        [ MD]   copied in index
    # [MARC]           index and work tree matches
    # [ MARC]     M    work tree changed since index
    # [ MARC]     D    deleted in work tree
    # [ D]        R    renamed in work tree
    # [ D]        C    copied in work tree
    # -------------------------------------------------
    # D           D    unmerged, both deleted
    # A           U    unmerged, added by us
    # U           D    unmerged, deleted by them
    # U           A    unmerged, added by them
    # D           U    unmerged, deleted by us
    # A           A    unmerged, both added
    # U           U    unmerged, both modified
    # -------------------------------------------------
    # ?           ?    untracked
    # !           !    ignored
    # -------------------------------------------------

    local \
        git_args=(-c color.status=always) \
        output=() \
        grouping \
        line section \
        quiet

    git-bid-clean-vars

    zparseopts -E -D -- q=quiet -quiet=quiet

    git_status=( "${(f@)$($GIT_BY_ID[GIT_CMD] $git_args status "$@")}" )
    GIT_IDS_COUNT=0

    # local ob="${fg[black]}[$reset_color" cb="${fg[black]}]$reset_color"
    local \
        _ob="${GIT_BY_ID[THEME_ob]}" \
        _cb="${GIT_BY_ID[THEME_cb]}" \
        _id="${GIT_BY_ID[THEME_id]}" \
        _del="${GIT_BY_ID[THEME_git-del]}" \
        _new="${GIT_BY_ID[THEME_git-new]}" \
        _both="${GIT_BY_ID[THEME_git-both]}" \
        _mod="${GIT_BY_ID[THEME_git-mod]}" \

    local ansi='\033\[[[:digit:]|;]*m'
    for line in "${(@)git_status}" ; {
        local match=() found_file=
        if [[ -z $line ]] {
        } elif [[ "$line" =~ "^($ansi)\s+\(.*\)" ]] {
        } elif [[ "$line" =~ 'Changes to be committed:' ]] {
            section=GIT_IDS_STAGED
        } elif [[ "$line" =~ 'Changes not staged for commit:' ]] {
            section=GIT_IDS_UNMERGED
        } elif [[ "$line" =~ 'Unmerged paths:' ]] {
            section=GIT_IDS_UNTRACKED
        } elif [[ "$line" =~ 'Untracked files:' ]] {
            section=GIT_IDS_UNTRACKED
        } elif [[ "$line" =~ "(\s+)($ansi)*(.*[deleted|both modified|modified|new file])(:)(\s+)(.*)$" ]] {
            local match_names=( lpad line_color kind colon rpad found_file ) i=0
            for (( i=1 ; i <= ${#match_names} ; i++ ))  local "${match_names[i]}"="$match[$i]"
            (( ${__trace__:-0} )) && [[ "$line_color" ]] && print -P "$kind ${line_color}found a color => %f${(q)line_color}"
            case "$kind" {
                (deleted)         kind="${_del}$line_color$kind" ;;
                (new*)            kind="${_new}$line_color$kind" ;;
                (both modified)   kind="${_both}$kind" ;;
                (modified)        kind="${_mod}$line_color$kind" ;;
                (*)               kind="?$line_color$kind" ; xlg-warn "plz handle '$kind'" ;;
            }
            : $(( ++GIT_IDS_COUNT ))
            local id_pad="__id_pad_${#GIT_IDS_COUNT}"  # add padding to the number based on how many files we have seen
            line="$lpad$_ob$_id$GIT_IDS_COUNT$_cb$id_pad $kind$colon$line_color$rpad$found_file"
        } elif [[ "$line" =~ "(\t)(.*)" ]] {
            local lpad="$match[1]" found_file="$match[2]"
            line="$lpad$_ob$_id$(( ++GIT_IDS_COUNT ))$_cb $found_file"
        }

        output+="$line"

        if [[ "${found_file}" ]] {
            found_file="${found_file//$'\033'\[([0-9;])#m/}"
            GIT_IDS+=([$GIT_IDS_COUNT]="$found_file")
            typeset -x "${section}[$GIT_IDS_COUNT]"="$found_file"
            (( GIT_BY_ID[SET_ID_VARS] )) && \
                export ${GIT_BY_ID[PREFIX_VAR]}$GIT_IDS_COUNT="$found_file"
        }
    }

    if [[ ! "$quiet" && "$output" ]] {
        # escape ` in output, print -P was interpreting them
        output="${(j:\n:)output:gs/\`/\\\\\`/}\n"
        (( GIT_IDS_COUNT >= 10 )) && output=${output//__id_pad_1/__id_pad_2 }
        (( GIT_IDS_COUNT >= 100 )) && output=${output//__id_pad_2/__id_pad_3 }
        (( GIT_IDS_COUNT >= 1000 )) && output=${output//__id_pad_3/__id_pad_4 }
        (( GIT_IDS_COUNT >= 10000 )) && output=${output//__id_pad_4/ }
        output=${output//__id_pad_[0-9]/}

        print -P "$output"

    }
    return $(( !GIT_IDS_COUNT ))
}
